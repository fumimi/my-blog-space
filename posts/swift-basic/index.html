<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="pinterest" content="nopin">
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="theme-color" content="#263238">

<meta name="generator" content="Hugo 0.27.1" />

<link rel="apple-touch-icon" href="https://fumimi.github.io/my-blog-space/images/logo.png">


<link rel="canonical" href="https://fumimi.github.io/my-blog-space/posts/swift-basic/">


    
    <link href="//fonts.googleapis.com/css?family=Roboto+Slab:400,700" rel="stylesheet">
    
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/solarized_dark.min.css">
    <title>Swiftを学ぶ - My Blog Space.</title>
    

<meta name="description" content="Swiftを学ぶ 「Hello, world!」と表示させる print(&amp;hellip;)は引数の内容をコンソールへ出力する関数です。print(&amp;quot;Hello, world!&amp;quot;)  変数と定数 var は変数、 let は定数です。var level = 10 level = 20 print(level) // 20  Swiftの変数は型を持っています。型（String、Int等）は変数を宣言する時に指定します。var name: String var level: Int name = &amp;quot;クリリン&amp;quot; level = 10 print(name) print(level)  但しSwiftには、型を自動的に推測する機能が備わっています。上でみたように型が明らかな場合は型宣言を省略することができます。var name = &amp;quot;クリリン&amp;quot; // 代入されている内容から型がString（文字列）なのは明らかなので、型は明示しなくてよい。 var level = 10 // この場合は型はInt（整数型）と判断されます。 var height1 = 153.0 // この場合は型はDouble（浮動小数型）と判断されます。（少数部がついた数値はデフォルトでDouble型になります。） var height2: Float = 153.0 // 型を明示する場合は、型付きで宣言する。 var height3: Double = 150  文字列補完を使って次の様に変数の値を文字列に含めて出力できます。">

<meta property="og:title" content="Swiftを学ぶ - My Blog Space.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://fumimi.github.io/my-blog-space/posts/swift-basic/">
<meta property="og:image" content="https://fumimi.github.io/my-blog-space/images/swift.png">
<meta property="og:site_name" content="My Blog Space.">
<meta property="og:description" content="Swiftを学ぶ 「Hello, world!」と表示させる print(&amp;hellip;)は引数の内容をコンソールへ出力する関数です。print(&amp;quot;Hello, world!&amp;quot;)  変数と定数 var は変数、 let は定数です。var level = 10 level = 20 print(level) // 20  Swiftの変数は型を持っています。型（String、Int等）は変数を宣言する時に指定します。var name: String var level: Int name = &amp;quot;クリリン&amp;quot; level = 10 print(name) print(level)  但しSwiftには、型を自動的に推測する機能が備わっています。上でみたように型が明らかな場合は型宣言を省略することができます。var name = &amp;quot;クリリン&amp;quot; // 代入されている内容から型がString（文字列）なのは明らかなので、型は明示しなくてよい。 var level = 10 // この場合は型はInt（整数型）と判断されます。 var height1 = 153.0 // この場合は型はDouble（浮動小数型）と判断されます。（少数部がついた数値はデフォルトでDouble型になります。） var height2: Float = 153.0 // 型を明示する場合は、型付きで宣言する。 var height3: Double = 150  文字列補完を使って次の様に変数の値を文字列に含めて出力できます。">
<meta property="og:locale" content="ja_JP">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="My Blog Space.">
<meta name="twitter:url" content="https://fumimi.github.io/my-blog-space/posts/swift-basic/">
<meta name="twitter:title" content="Swiftを学ぶ - My Blog Space.">
<meta name="twitter:description" content="Swiftを学ぶ 「Hello, world!」と表示させる print(&amp;hellip;)は引数の内容をコンソールへ出力する関数です。print(&amp;quot;Hello, world!&amp;quot;)  変数と定数 var は変数、 let は定数です。var level = 10 level = 20 print(level) // 20  Swiftの変数は型を持っています。型（String、Int等）は変数を宣言する時に指定します。var name: String var level: Int name = &amp;quot;クリリン&amp;quot; level = 10 print(name) print(level)  但しSwiftには、型を自動的に推測する機能が備わっています。上でみたように型が明らかな場合は型宣言を省略することができます。var name = &amp;quot;クリリン&amp;quot; // 代入されている内容から型がString（文字列）なのは明らかなので、型は明示しなくてよい。 var level = 10 // この場合は型はInt（整数型）と判断されます。 var height1 = 153.0 // この場合は型はDouble（浮動小数型）と判断されます。（少数部がついた数値はデフォルトでDouble型になります。） var height2: Float = 153.0 // 型を明示する場合は、型付きで宣言する。 var height3: Double = 150  文字列補完を使って次の様に変数の値を文字列に含めて出力できます。">
<meta name="twitter:image" content="https://fumimi.github.io/my-blog-space/images/swift.png">


<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "NewsArticle",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id":"https://fumimi.github.io/my-blog-space/"
    },
    "headline": "Swiftを学ぶ - My Blog Space.",
    "image": {
      "@type": "ImageObject",
      "url": "https://fumimi.github.io/my-blog-space/images/swift.png",
      "height": 800,
      "width": 800
    },
    "datePublished": "2017-10-22T08:30:59JST",
    "dateModified": "2017-10-22T08:30:59JST",
    "author": {
      "@type": "Person",
      "name": "My Blog Space."
    },
    "publisher": {
      "@type": "Organization",
      "name": "My Blog Space.",
      "logo": {
        "@type": "ImageObject",
        "url": "https://fumimi.github.io/my-blog-space/images/logo.png",
        "width": 600,
        "height": 60
      }
    },
    "description": "Swiftを学ぶ 「Hello, world!」と表示させる print(&hellip;)は引数の内容をコンソールへ出力する関数です。
print(&quot;Hello, world!&quot;)  変数と定数 var は変数、 let は定数です。
var level = 10 level = 20 print(level) // 20  Swiftの変数は型を持っています。型（String、Int等）は変数を宣言する時に指定します。
var name: String var level: Int name = &quot;クリリン&quot; level = 10 print(name) print(level)  但しSwiftには、型を自動的に推測する機能が備わっています。上でみたように型が明らかな場合は型宣言を省略することができます。
var name = &quot;クリリン&quot; // 代入されている内容から型がString（文字列）なのは明らかなので、型は明示しなくてよい。 var level = 10 // この場合は型はInt（整数型）と判断されます。 var height1 = 153.0 // この場合は型はDouble（浮動小数型）と判断されます。（少数部がついた数値はデフォルトでDouble型になります。） var height2: Float = 153.0 // 型を明示する場合は、型付きで宣言する。 var height3: Double = 150  文字列補完を使って次の様に変数の値を文字列に含めて出力できます。"
  }
</script>


    <style>
      html { font-size: 18px; background-color: rgba(236,239,241,.5);}@media (max-width: 768px) { html { font-size: 15px; }}body { color: #333; font-family: 'Roboto Slab','ヒラギノ角ゴ Pro W3','Hiragino Kaku Gothic Pro',メイリオ,Meiryo,sans-serif; font-feature-settings : "palt"; font-size: inherit; line-height: 1rem; margin: 0; padding: 0;}h1, h2, h3, h4, h5 ,h6 { font-size: 1rem; font-weight: 700; line-height: 1rem; margin: 0;}hr { border: 0; border-top: 1px dashed #cfd8dc; margin: 1rem 0;}p { margin: 0; line-height: 1rem;}a { color: #2196f3; text-decoration: none; transition-duration: .3s;}ul, ol { margin: 0; padding: 0;}table { border-collapse: collapse;}th, td { font-size: .8rem; padding: .5rem;}tr { border-bottom: 1px dashed #ddd;}/* Layouts */main,aside { display: block;}main { padding: 1rem 0 3rem 0; }aside.h { padding: 3rem 0; }main.f,aside.f { background-color: #333; border-top: 2px dashed #fff; border-bottom: 2px dashed #fff;}.l-container { position: relative; max-width: 68rem; margin: 0 auto; padding: 0 1rem;}.l-container.thin { max-width: 44rem;}.l-header { background-color: #fff; box-shadow: 0 0 0 1px rgba(63,63,68,.05), 0 1px 3px rgba(63,63,68,.1), 0 1px 2px rgba(0,0,0,.05); padding: 1rem 0; text-align: center;}.l-header .description { margin-top: .5rem; font-size: .8rem;}.l-footer { background-color: #fff; box-shadow: 0 0 0 1px rgba(63,63,68,.05), 0 1px 3px rgba(63,63,68,.1), 0 1px 2px rgba(0,0,0,.05); font-size: .6rem; font-weight: 700; padding: 1rem 0;}@media (max-width: 768px) { .l-sidebar { margin-top: 4rem; }}.mrow { margin: 0 -1rem; overflow: hidden;}.mcol { box-sizing: border-box; float: left; padding: 0 1rem;}.c6 { width: 50%; }.c4 { width: 33.26323833%; }.c8 { width: 66.66666%; }@media (max-width: 768px) { .mcol { width: 100%; float: none; }}.logo a { font-size: 1.4rem; line-height: 1.5rem; font-weight: 700; color: #333;}.articles { margin: -1rem 0; margin-bottom: 1rem;}.articles.sm { margin: -.5rem 0; margin-bottom: 0;}article { border-radius: 4px; overflow: hidden;}article.li { background-color: #fff; box-shadow: 0 0 0 1px rgba(63,63,68,.05), 0 1px 3px rgba(63,63,68,.1), 0 1px 2px rgba(0,0,0,.05); height: 20rem; overflow: hidden; margin: 1rem 0;}article.li > a { display: block; color: #333;}article.li .inner { padding: 1rem;}article.li .thumb { height: 8rem;}article.li .title { color: #333; font-size: 1.2rem; line-height: 1.5rem; margin-bottom: .5rem;}article.li .summary { font-size: .8rem; height: 6rem; overflow: hidden; margin-top: 1rem;}article.li .summary::after { content: '...';}article.lism { background-color: #fff; box-shadow: 0 0 0 1px rgba(63,63,68,.05), 0 1px 3px rgba(63,63,68,.1), 0 1px 2px rgba(0,0,0,.05); margin: .5rem 0;}article.lism::after { content: ''; display: block; clear: both;}article.lism > a { display: block; color: #333;}article.lism .inner { display: table-cell; vertical-align: middle; height: 5rem; padding: 0 .75rem;}article.lism .thumb { width: 5rem; height: 5rem; float: left;}article.lism .title { font-weight: 700; font-size: .8rem; margin-bottom: .25rem;}article.sn { background-color: #fff; box-shadow: 0 0 0 1px rgba(63,63,68,.05), 0 1px 3px rgba(63,63,68,.1), 0 1px 2px rgba(0,0,0,.05); margin-bottom: 1rem;}article.sn .thumb { height: 20rem;}@media (max-width: 768px) { article.sn .thumb { height: 10rem; }}article.sn > .article-header,article.sn > .article-body,article.sn .article-footer { padding: 2rem;}article.sn > .article-body { padding: 0 2rem;}@media (max-width: 768px) { article.sn > .article-header, article.sn > .article-body, article.sn .article-footer { padding: 1rem; } article.sn > .article-body { padding: 0 1rem; }}article.sn > .article-header .title { font-size: 1.8rem; line-height: 2rem; margin-bottom: .5rem;}@media (max-width: 768px) { article.sn > .article-header .title { font-size: 1.4rem; line-height: 1.5rem; }}article.sn > .article-header .facts { margin-bottom: 1rem;}article.sn > .article-body { margin-bottom: 1.5rem;}article.sn > .article-body h2 { border-bottom: .25rem solid #333; font-size: 1.2rem; line-height: 1.5rem; margin: 1.5rem 0; padding: .5rem 0;}article.sn > .article-body h3 { border-left: .5rem solid #333; line-height: 1.5rem; margin: 1.5rem 0; padding: .125rem .5rem;}article.sn > .article-body ul,article.sn > .article-body ol { margin: 1.5rem 0; padding-left: 1.5rem;}article.sn > .article-body li { padding-bottom: .5rem; line-height: 1.5rem;}article.sn > .article-body li:last-child { padding-bottom: 0;}article.sn > .article-body p { margin: 1rem 0; line-height: 1.5rem;}article.sn > .article-body strong,article.sn > .article-body em { font-style: normal; font-weight: 700;}article.sn > .article-body strong { box-shadow: 0 -.5rem 0 0 #ffc107 inset;}article.sn > .article-body em { color: #8bc34a;}article.sn > .article-body code,article.sn > .article-body pre { font-family: Menlo, Consolas, monospace; font-size: .7rem;}article.sn > .article-body pre { background-color: #333; color: #fff; line-height: 1rem; margin: 1.5rem -2rem; overflow: auto;}@media (max-width: 768px) { article.sn > .article-body pre { margin: 1.5rem -1rem; }}article.sn > .article-body pre > code { display: block; padding: 1rem 2rem;}@media (max-width: 768px) { article.sn > .article-body pre > code { padding: 1rem; }}article.sn > .article-body p code { background-color: #eceff1; color: #333; border-radius: 4px; margin: 0 .25rem; padding: .375rem; white-space: nowrap;}article.sn > .article-body blockquote { position: relative; border-left: .25rem solid #333; font-size: .8rem; padding: .125rem 1rem; margin: 1.5rem 0;}@media (max-width: 768px) { article.sn > .article-body blockquote { font-size: 1rem; }}article.sn > .article-body blockquote p { margin: .5rem 0; line-height: 1rem;}article.sn > .article-body figure { margin: 1.5rem 0;}article.sn > .article-body figure img,article.sn > .article-body figure amp-img { box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24); max-width: 100%;}article.sn > .article-body figcaption { color: #cfd8dc; font-size: .8rem; font-weight: 700; margin-top: .5rem;}.facts li { display: inline; font-size: .8rem; margin-right: 1rem;}.facts i { color: #cfd8dc; margin-right: .5em;}.facts.sm li { font-size: .7rem;}.sections.sidebar { margin: -1rem 0;}.sections.footer { margin: -1rem 0;}section.sidebar { margin: 2rem 0;}section.sidebar > header { font-size: .8rem; font-weight: 700; letter-spacing: 4px; text-align: center; margin: 1.5rem 0;}section.footer { margin: 1rem 0;}section.footer > header { font-size: .8rem; margin: .5rem 0;}section.footer > header::before { content: "- ";}section.footer > header a { font-weight: 700; color: #333; text-decoration: underline;}.terms { margin: -.25rem;}.terms li { display: inline-block;}.terms a { display: block; float: left; background-color: #333; border-radius: 4px; color: #fff; font-size: .7rem; margin: .25rem; padding: 0 .75rem; line-height: 1.75rem;}.paging { text-align: center; padding: 1rem 0;}.paging a { display: inline-block; background-color: #fff; box-shadow: 0 0 0 1px rgba(63,63,68,.05), 0 1px 3px rgba(63,63,68,.1), 0 1px 2px rgba(0,0,0,.05); border-radius: 4px; color: #333; padding: 0 1rem; line-height: 3rem;}.page-title { text-align: center; margin: 1rem 0;}.page-title::after { content: ''; display: block; border-bottom: .25rem solid #333; width: 3rem; margin: 1.5rem auto;}.page-title > .title { font-size: 1.2rem; line-height: 1.5rem;}/* Parts:breadcrumb */.crumb ol { text-overflow: ellipsis; color: #cfd8dc; white-space: nowrap; overflow: hidden;}.crumb li { display: inline; font-size: .8rem;}.crumb li::after { content: '›'; margin: 0 .25rem 0 .5rem;}.crumb li:last-child::after { content: '';}.crumb a { color: #cfd8dc;}.crumb i { margin-right: .5em;}.share { padding: 0;}.share a { display: inline-block; box-shadow: 0 0 0 1px rgba(63,63,68,.05), 0 1px 3px rgba(63,63,68,.1), 0 1px 2px rgba(0,0,0,.05); min-width: 1rem; height: 2rem; border-radius: 4px; color: #333; font-size: .8rem; font-weight: 700; line-height: 2rem; text-align: center; padding: 0 .5rem;}.adj article.lism { margin-bottom: 1rem;}.adj header { font-weight: 700; font-size: .8rem;}.toc { padding: 0 2rem;}@media (max-width: 768px) { .toc { padding: 0 1rem; }}.toc { margin: 1rem 0;}.toc nav>ul { background-color: #eceff1; border-radius: 4px; display: inline-block; font-size: .8rem; padding: .5rem 1rem; word-break: break-all; list-style: none;}.toc ul { padding: 0;}.toc ul ul { padding-left: 1rem;}.toc ul ul ul { padding-left: 1rem;}.toc li { color: #90a4ae;}.toc ul ul>li { font-weight: 700; margin: .5rem 0; list-style-type: decimal;}.toc ul ul ul>li { list-style-type: disc; font-weight: 500;}.author { background-color: #fff; box-shadow: 0 0 0 1px rgba(63,63,68,.05), 0 1px 3px rgba(63,63,68,.1), 0 1px 2px rgba(0,0,0,.05); padding: 1rem; border-radius: 4px; text-align: center;}.author .author-thumb { margin: 0 auto 1rem; width: 6rem; height: 6rem; border-radius: 50%; background-color: #eceff1; background-size: cover; background-position: center;}.author .author-name { margin-bottom: .5rem; font-weight: 700;}.author .author-facts { margin-bottom: 1rem;}.author .author-facts li { display: inline;}.author .author-facts li a { display: inline-block; background-color: #eceff1; width: 1.75rem; height: 1.75rem; line-height: 1.75rem; text-align: center; color: #333; font-size: .8rem; border-radius: 2px;}.author .author-facts li a:hover { color: #fff; background-color: #333;}.author .author-description { text-align: left; font-size: .8rem;}.author .author-description p { margin: .5rem 0;}.thumb { background-image: url(https://fumimi.github.io/my-blog-space/images/default.jpg); background-size: cover; background-position: center;}.thumb-dbde06035db760652386e5fc4994ce99 { background-image: url(https://fumimi.github.io/my-blog-space/images/swift.png);}.thumb-73fc7deb3f652a22833fb3f4da0ed2eb { background-image: url(https://fumimi.github.io/my-blog-space/images/hoge.jpg);}.thumb-583bc6c089052d23ac6c3a855c17f6df { background-image: url(https://fumimi.github.io/my-blog-space/images/hoge.jpg);}
      
      
      
    </style>
  </head>

  <body>
    
    
    

    <header class="l-header">
      <div class="l-container">
        <div class="logo">
          <a href="https://fumimi.github.io/my-blog-space/">My Blog Space.</a>
        </div>
        

      </div>
    </header>

    <main>
      <div class="l-container">
        
<div class="mrow">
  <div class="mcol c8">

    <article class="sn">

  <div class="thumb thumb-dbde06035db760652386e5fc4994ce99"></div>

  <header class="article-header">
    <h1 class="title">Swiftを学ぶ</h1>

    <ul class="facts">
      <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2017-10-22T08:30:59JST">Oct 22, 2017</time></li>
      <li><i class="fa fa-bookmark" aria-hidden="true"></i><a href="https://fumimi.github.io/my-blog-space/posts/">POSTS</a></li>
      
    </ul>

    <aside class="share">
  <a href="http://b.hatena.ne.jp/add?mode=confirm&url=https%3a%2f%2ffumimi.github.io%2fmy-blog-space%2fposts%2fswift-basic%2f&title=Swift%e3%82%92%e5%ad%a6%e3%81%b6" title="はてなブックマーク" class="ht" target="_blank" rel="nofollow">B!</a>
  <a href="http://twitter.com/intent/tweet?url=https%3a%2f%2ffumimi.github.io%2fmy-blog-space%2fposts%2fswift-basic%2f&text=Swift%e3%82%92%e5%ad%a6%e3%81%b6&tw_p=tweetbutton" title="Twitterでシェア" class="tw" target="_blank" rel="nofollow"><i class="fa fa-twitter" aria-hidden="true"></i></a>
  <a href="http://www.facebook.com/sharer.php?u=https%3a%2f%2ffumimi.github.io%2fmy-blog-space%2fposts%2fswift-basic%2f&t=Swift%e3%82%92%e5%ad%a6%e3%81%b6" title="Facebookでシェア" class="fb" target="_blank" rel="nofollow"><i class="fa fa-facebook" aria-hidden="true"></i></a>
  <a href="https://plus.google.com/share?url=https%3a%2f%2ffumimi.github.io%2fmy-blog-space%2fposts%2fswift-basic%2f" title="Google Plusでシェア" class="gp" target="_blank" rel="nofollow"><i class="fa fa-google-plus" aria-hidden="true"></i></a>
  <a href="http://getpocket.com/edit?url=https%3a%2f%2ffumimi.github.io%2fmy-blog-space%2fposts%2fswift-basic%2f&title=Swift%e3%82%92%e5%ad%a6%e3%81%b6" title="Pocketに保存" class="pk" target="_blank" rel="nofollow"><i class="fa fa-get-pocket" aria-hidden="true"></i></a>
  <a href="http://line.me/R/msg/text/?Swift%e3%82%92%e5%ad%a6%e3%81%b6 https%3a%2f%2ffumimi.github.io%2fmy-blog-space%2fposts%2fswift-basic%2f" title="LINEでシェア" class="ln" target="_blank" rel="nofollow">LINE</a>
</aside>

  </header>

  
  <div class="toc">
    <nav id="TableOfContents">
<ul>
<li><a href="#swiftを学ぶ">Swiftを学ぶ</a>
<ul>
<li><a href="#hello-world-と表示させる">「Hello, world!」と表示させる</a></li>
<li><a href="#変数と定数">変数と定数</a></li>
<li><a href="#型">型</a>
<ul>
<li><a href="#数値型">数値型</a></li>
<li><a href="#論理型">論理型</a></li>
<li><a href="#文字列型">文字列型</a></li>
<li><a href="#特殊文字">特殊文字</a></li>
<li><a href="#文字列の操作">文字列の操作</a></li>
<li><a href="#文字列補完">文字列補完</a></li>
<li><a href="#ユニコード">ユニコード</a></li>
<li><a href="#タプル">タプル</a></li>
<li><a href="#配列">配列</a>
<ul>
<li><a href="#宣言">宣言</a></li>
</ul></li>
<li><a href="#ディクショナリ">ディクショナリ</a></li>
</ul></li>
<li><a href="#オプショナル型">オプショナル型</a>
<ul>
<li><a href="#宣言-1">宣言</a></li>
<li><a href="#オプショナルバインディング">オプショナルバインディング</a></li>
<li><a href="#アンラップ">アンラップ</a></li>
<li><a href="#暗黙的なオプショナル型">暗黙的なオプショナル型</a></li>
<li><a href="#nil結合演算子">nil結合演算子</a></li>
</ul></li>
<li><a href="#タイプエイリアス">タイプエイリアス</a></li>
<li><a href="#列挙型">列挙型</a>
<ul>
<li><a href="#宣言-2">宣言</a></li>
<li><a href="#関連値">関連値</a></li>
</ul></li>
<li><a href="#制御文">制御文</a>
<ul>
<li><a href="#if">if</a></li>
<li><a href="#for">for</a></li>
<li><a href="#while">while</a></li>
<li><a href="#switch">switch</a></li>
</ul></li>
<li><a href="#関数">関数</a>
<ul>
<li><a href="#宣言-3">宣言</a></li>
<li><a href="#外部引数名">外部引数名</a></li>
<li><a href="#引数の規定値">引数の規定値</a></li>
<li><a href="#可変数個引数">可変数個引数</a></li>
<li><a href="#定数引数と可変引数">定数引数と可変引数</a></li>
<li><a href="#関数型">関数型</a></li>
<li><a href="#無名関数">無名関数</a></li>
<li><a href="#関数のネスト">関数のネスト</a></li>
<li><a href="#クロージャ">クロージャ</a></li>
</ul></li>
<li><a href="#クラス">クラス</a>
<ul>
<li><a href="#インスタンスの生成">インスタンスの生成</a></li>
<li><a href="#イニシャライザ">イニシャライザ</a></li>
<li><a href="#デイニシャライザ">デイニシャライザ</a></li>
<li><a href="#ゲッターとセッター">ゲッターとセッター</a></li>
<li><a href="#同一インスタンスの判定">同一インスタンスの判定</a></li>
</ul></li>
<li><a href="#構造体">構造体</a></li>
<li><a href="#プロパティ">プロパティ</a>
<ul>
<li><a href="#保持型プロパティ">保持型プロパティ</a></li>
<li><a href="#計算型プロパティ">計算型プロパティ</a></li>
<li><a href="#プロパティ監視">プロパティ監視</a></li>
<li><a href="#型プロパティ">型プロパティ</a></li>
</ul></li>
<li><a href="#メソッド">メソッド</a>
<ul>
<li><a href="#インスタンスメソッド">インスタンスメソッド</a></li>
<li><a href="#引数名">引数名</a></li>
<li><a href="#破壊的メソッド">破壊的メソッド</a></li>
<li><a href="#型メソッド">型メソッド</a></li>
</ul></li>
<li><a href="#サブスクリプト">サブスクリプト</a></li>
<li><a href="#継承">継承</a>
<ul>
<li><a href="#サブクラス">サブクラス</a></li>
<li><a href="#ポリモーフィズム">ポリモーフィズム</a></li>
<li><a href="#オーバーライド">オーバーライド</a></li>
<li><a href="#オーバーライドの禁止">オーバーライドの禁止</a></li>
</ul></li>
<li><a href="#イニシャライザ-1">イニシャライザ</a>
<ul>
<li><a href="#構造体-1">構造体</a></li>
<li><a href="#クラス-1">クラス</a></li>
<li><a href="#イニシャライザの自動継承">イニシャライザの自動継承</a></li>
<li><a href="#イニシャライザの継承">イニシャライザの継承</a></li>
<li><a href="#必須イニシャライザ">必須イニシャライザ</a></li>
<li><a href="#関数オブジェクトによるプロパティの初期化">関数オブジェクトによるプロパティの初期化</a></li>
</ul></li>
<li><a href="#デイニシャライザ-1">デイニシャライザ</a></li>
<li><a href="#arc">ARC</a></li>
<li><a href="#オプショナルの連鎖">オプショナルの連鎖</a></li>
<li><a href="#型キャスト">型キャスト</a></li>
<li><a href="#ネストした型">ネストした型</a></li>
<li><a href="#エクステンション">エクステンション</a></li>
<li><a href="#プロトコル">プロトコル</a></li>
<li><a href="#ジェネリクス">ジェネリクス</a></li>
<li><a href="#アクセスコントロール">アクセスコントロール</a></li>
<li><a href="#演算子のオーバーロード">演算子のオーバーロード</a></li>
</ul></li>
</ul>
</nav>
  </div>
  

  <div class="article-body">

<h1 id="swiftを学ぶ">Swiftを学ぶ</h1>

<h2 id="hello-world-と表示させる">「Hello, world!」と表示させる</h2>

<p>print(&hellip;)は引数の内容をコンソールへ出力する関数です。</p>

<pre><code>print(&quot;Hello, world!&quot;)
</code></pre>

<h2 id="変数と定数">変数と定数</h2>

<p><code>var</code> は<strong>変数</strong>、 <code>let</code> は<strong>定数</strong>です。</p>

<pre><code>var level = 10
level = 20
print(level) // 20
</code></pre>

<p>Swiftの変数は型を持っています。型（String、Int等）は変数を宣言する時に指定します。</p>

<pre><code>var name: String
var level: Int

name = &quot;クリリン&quot;
level = 10

print(name)
print(level)
</code></pre>

<p>但しSwiftには、型を自動的に推測する機能が備わっています。上でみたように型が明らかな場合は型宣言を省略することができます。</p>

<pre><code>var name = &quot;クリリン&quot;          // 代入されている内容から型がString（文字列）なのは明らかなので、型は明示しなくてよい。
var level = 10               // この場合は型はInt（整数型）と判断されます。
var height1 = 153.0          // この場合は型はDouble（浮動小数型）と判断されます。（少数部がついた数値はデフォルトでDouble型になります。）
var height2: Float = 153.0   // 型を明示する場合は、型付きで宣言する。
var height3: Double = 150
</code></pre>

<p>文字列補完を使って次の様に変数の値を文字列に含めて出力できます。</p>

<pre><code>let name = &quot;山田太郎&quot;
var age = 30
print(&quot;名前:\(name) 年齢:\(age)歳&quot;)    // 名前:山田太郎 年齢:30歳
</code></pre>

<h2 id="型">型</h2>

<p>Swiftの基本的な型には、数値型、論理型、文字型、タプル、配列、ディクショナリがあります。</p>

<h3 id="数値型">数値型</h3>

<p>型を指定しない場合はIntとなる。</p>

<pre><code>var width: Int
width = 200
let height = 300// 型を指定しない場合はInt
</code></pre>

<h3 id="論理型">論理型</h3>

<p>論理型は（true）か（false）の２値をとる型で、Boolで指定します。変数の宣言時にtrue又はfalseを代入すると暗黙的にBool型になります。</p>

<pre><code>var answer: Bool
var success = true
let result = (100 == 200)   // false
</code></pre>

<h3 id="文字列型">文字列型</h3>

<p>文字型はStringで指定します。変数の宣言時に&rdquo;（ダブルクォーテーション）で囲まれた文字列を代入すると暗黙的にString型となります。</p>

<pre><code>let name: String
var job = &quot;戦士&quot;
var number = String(123)   // &quot;123&quot;
</code></pre>

<h3 id="特殊文字">特殊文字</h3>

<p>文字列中に以下のような特殊文字を含めることができます。</p>

<table>
<thead>
<tr>
<th align="left">文字</th>
<th align="left">意味</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">\0</td>
<td align="left">ヌル文字</td>
</tr>

<tr>
<td align="left">\</td>
<td align="left">バックスラッシュ</td>
</tr>

<tr>
<td align="left">\t</td>
<td align="left">水平タブ</td>
</tr>

<tr>
<td align="left">\n</td>
<td align="left">ラインフィード</td>
</tr>

<tr>
<td align="left">\r</td>
<td align="left">改行</td>
</tr>

<tr>
<td align="left">\&rdquo;</td>
<td align="left">ダブルクォート</td>
</tr>

<tr>
<td align="left">\&rsquo;</td>
<td align="left">シングルクォート</td>
</tr>

<tr>
<td align="left">\u{nn}</td>
<td align="left">1バイトのユニコードスカラ値（nnは2桁の16進数値）</td>
</tr>

<tr>
<td align="left">\u{nnnn}</td>
<td align="left">2バイトのユニコードスカラ値（nnnnは4桁の16進数値）</td>
</tr>

<tr>
<td align="left">\u{nnnnnnnn}</td>
<td align="left">4バイトのユニコードスカラ値（nnnnnnnnは8桁の16進数値）</td>
</tr>
</tbody>
</table>

<pre><code>let message = &quot;He said, \&quot;I\'m going to be a king of pirates!\&quot;&quot;
let atmark = &quot;\u{40}&quot;     // @
let heart = &quot;\u{2665}&quot;    // ♥︎
</code></pre>

<h3 id="文字列の操作">文字列の操作</h3>

<p><strong>空文字</strong></p>

<p>空文字は以下のようにして定義できます。</p>

<pre><code>var name1 = &quot;&quot;
var name2 = String()
</code></pre>

<p>また、空文字かどうかは、isEmptyプロパティで判定できます。</p>

<pre><code>if name1.isEmpty {
    print(&quot;名前はまだない&quot;)
}
</code></pre>

<p><strong>長さを調べる</strong></p>

<p>文字列の長さは、countElements関数で調べることができます。</p>

<pre><code>var text = &quot;Swiftの学習&quot;
print(countElements(text))    // 8
</code></pre>

<p><strong>連結</strong></p>

<p>文字列を連結するには、+または、+=演算子を使います。</p>

<pre><code>let prefix = &quot;今日の天気は&quot;
let weather = &quot;晴れ&quot;
let suffix = &quot;です。&quot;
var message = prefix + weather  // 今日の天気は晴れ
message += suffix               // 今日の天気は晴れです。
</code></pre>

<p>他の型と連結するには、文字列に変換してから連結します。</p>

<pre><code>var hitPoint = 10
var message = &quot;スライムのHPは&quot; + String(hitPoint) + &quot;です。&quot; // スライムのHPは10です。
</code></pre>

<p>StringとCharacter同士も+演算子でそのまま連結することはできないので変換が必要です。</p>

<pre><code>let hello: String = &quot;Hello&quot;
let mark: Character = &quot;!&quot;
print(hello + String(mark))
</code></pre>

<p>但し、appendメソッドで連結することは可能です。</p>

<pre><code>var hello: String = &quot;Hello&quot;
let mark: Character = &quot;!&quot;

hello.append(mark)  // Hello!
</code></pre>

<p><strong>補完</strong></p>

<p>文字列中に、( と ) で囲んで変数の値を含めることができます。</p>

<pre><code>var hitPoint = 10
var message = &quot;スライムのHPは\(hitPoint)です。&quot; // スライムのHPは10です。
</code></pre>

<p>計算式や関数の呼び出しを含めることもできます。</p>

<pre><code>var formula = &quot;2 x 3 = \(2*3)&quot;      // 2 x 3 = 6
var message = &quot;結果は\(someFunc())&quot;  // 結果は???
</code></pre>

<p><strong>比較</strong></p>

<p>文字列の比較には数値の場合と同様、==、&lt;、&lt;=、&gt;、&gt;= が使用できます。</p>

<pre><code>let a = &quot;A&quot;
let b = &quot;B&quot;
if a == b {
    print(&quot;同じ&quot;)
} else if a &lt; b {
    print(&quot;\(a)より\(b)の方が大きい&quot;)
} else {
    print(&quot;\(b)より\(a)の方が大きい&quot;)
}
</code></pre>

<p>StringのhasPrefix、hasSuffixメソッドで、文字列の前方と後方にそれぞれ指定した文字列が含まれるか判定することができます。</p>

<pre><code>let a = &quot;醤油ラーメン&quot;
let b = &quot;みそラーメン&quot;
let c = &quot;味噌汁&quot;
print(a.hasPrefix(&quot;みそ&quot;))  // false
print(b.hasPrefix(&quot;みそ&quot;))  // true
print(c.hasPrefix(&quot;みそ&quot;))  // false
print(a.hasSuffix(&quot;ラーメン&quot;))  // true
print(b.hasSuffix(&quot;ラーメン&quot;))  // true
print(c.hasSuffix(&quot;ラーメン&quot;))  // false
</code></pre>

<p>文字列を大文字、小文字に変換するには、StringのuppercaseString、lowercaseStringメソッドを使用します。</p>

<pre><code>let a = &quot;This is a pen.&quot;
print(a.uppercaseString)  // THIS IS A PEN.
print(a.lowercaseString)  // this is a pen.
</code></pre>

<p>String型はCharacter型（ユニコード文字）の集りとみなすことができます。forループで回して文字列から１つずつCharacter型の変数に取り出すことができます。</p>

<pre><code>var dog: Character = &quot;dog.png&quot;
print(dog)

let str = &quot;Hello, 世界！&quot;
for ch in str { // chはCharacter型
    print(ch)
}
/*
H
e
l
l
o
,

世
界
！
*/
</code></pre>

<p><strong>部分文字列</strong></p>

<p>指定した位置以降の文字列を取り出すには、substringFromIndexメソッドを使います。また、指定した位置まで文字列を取り出すには、substringToIndexメソッドを使います。</p>

<p>但し、substringToIndexメソッドにはString.Index型を渡す必要があるので少々面倒です。Int型の数値は直接渡せません。</p>

<pre><code>let str = &quot;abcdefghij&quot;
var idx: String.Index
idx = advance(str.startIndex, 3)         // advance関数で位置3のインデックスを取得
print(str.substringFromIndex(idx))     // defghij
idx = advance(str.startIndex, 5)         // advance関数で位置5のインデックスを取得
print(str.substringToIndex(idx))       // abcde
</code></pre>

<p>NSStringにキャストしてやると、数値をそのままインデックスとして使用できます。</p>

<pre><code>print((str as NSString).substringFromIndex(3))     // defghij
print((str as NSString).substringToIndex(5))       // abcde
</code></pre>

<p>substringFromIndexとsubstringToIndexを組み合わせると部分文字列を取り出すことができます。</p>

<pre><code>let str = &quot;abcdefghij&quot;
let startIndex = advance(str.startIndex, 3)
let endIndex = advance(str.startIndex, 5)
print(str.substringFromIndex(startIndex).substringToIndex(endIndex))    // defgh
</code></pre>

<p>部分文字列を取り出すには、substringWithRangeメソッドを使う方法もあります。こちらは、String.Index型のRangeを渡す必要があります。（Int型のRangeではありません。）</p>

<pre><code>let str = &quot;abcdefghij&quot;
let startIndex = advance(str.startIndex, 2)   // advance関数で位置2のインデックスを取得
let endIndex = advance(str.startIndex, 5)     // 同じく位置5のインデックスを取得
print(str.substringWithRange(startIndex..&lt;endIndex)) // cde
print(str.substringWithRange(startIndex...endIndex)) // cdef
</code></pre>

<p><strong>検索</strong></p>

<p>指定した文字列が含まれるかどうか調べるには、rangeOfStringメソッドが使用できます。rangeOfStringメソッドは、String.Index型のRangeを返すので、Range.isEmptyを調べることで、文字列が含まれるかどうか調べることができます。</p>

<pre><code>let str = &quot;abcdefghij&quot;
if let r = str.rangeOfString(&quot;def&quot;) {
    print(&quot;見つかった&quot;)
} else {
    print(&quot;見つからない&quot;)
}
</code></pre>

<p>rangeOfStringメソッドにオプションを指定することで、大文字小文字を無視した検索も可能です。（NSStringで使用するNSStringCompareOptionsと同様のオプションを指定できます。）</p>

<pre><code>let str = &quot;abcdefghij&quot;
if let r = str.rangeOfString(&quot;DeF&quot;, options:.CaseInsensitiveSearch) {
    print(&quot;見つかった&quot;)
}
</code></pre>

<h3 id="文字列補完">文字列補完</h3>

<p>文字列の中に、他の変数の値や計算結果を埋め込むことができます。</p>

<pre><code>let title = &quot;円の面積&quot;
let pi = 3.14
var radius = 20
// 円の面積: 3.14 x 20 x 20 = 1256.0
let str = &quot;\(title): \(pi) x \(radius) x \(radius) = \(pi * Double(radius) * Double(radius))&quot;
</code></pre>

<h3 id="ユニコード">ユニコード</h3>

<p><strong>スカラー値とサロゲートペア</strong></p>

<p>Swiftは、ユニコードを強力にサポートする言語で、Stringは内部的にユニコードの21ビットスカラー値で表現されています。これは文字コードにUTF-16を使っているObjective-Cとは異なります。
ユニコードのスカラー値は、U+0000〜U+D7FFとU+E000〜U+10FFFFのコードポイントで表現されます。ここで除外されているU+D800〜U+DFFFはサロゲート（代用）と呼ばれ、スカラー値には含まれません。このU+D800〜U+DBFFの前半部分と、U+DC00〜U+DFFFの後半部分のそれぞれ1024文字分ずつの組み合わせ（ペア）をサロゲートペアと呼び、BMP（基本他言語面）以外の拡張文字等を表現するために使用されます。
21ビットの各スカラー値の全てが、Character型の文字として割り当てらているわけではなく、一部は将来の目的のために予約されています。</p>

<p><strong>書記素クラスタ</strong></p>

<p>ユニコードには、書記素クラスタと呼ばれる、それ単独では文字として成り立たなくても、他の文字と組み合わせることで単独の文字となる要素があります。</p>

<p>例えば、éはコードポイントU+00E9で表現されますが、e（U+0065）とアクセント記号（U+0301）の組み合わせでも表現できます。そしてこれらは何れも単一のCharacter型となります。また、これらを比較すると同一文字として認識されます。</p>

<pre><code>// どちらもé
var a, b: Character
a = &quot;\u{00e9}&quot;          // é
b = &quot;\u{0065}\u{0301}&quot;  // é
print(a == b)         // true
</code></pre>

<p>逆に、見た目は同じでもコードポイントが異なる文字もあります。これらの比較結果は同一文字とはみなされません。</p>

<pre><code>let a = &quot;\u{0041}&quot;  // 英語のA
let b = &quot;\u{0410}&quot;  // ロシア語のА
print(a == b)     // false 文字としては別物
</code></pre>

<p>また、文字を装飾するために使用される書記素クラスタもあります。例えば、U+20DDは、直前の文字を○で囲みます。</p>

<pre><code>var c = &quot;\u{E9}\u{20DD}&quot;     // ecircle.png
var d = &quot;ア\u{20DD}&quot;         // ㋐
</code></pre>

<p>これらも１文字を構成するコードポイントは複数になりますが、実際の文字としては1文字となります。</p>

<p>この様に、ユニコードのスカラー値で構成された文字列の長さは単純にバイト数で判断できないため、Swiftでは、String型の長さを調べるために、countElements(&hellip;)というグローバル関数が用意されています。これは文字列の頭からカウントしながら文字数を調べるため長い文字列の場合はその分、時間がかかることになります。</p>

<pre><code>countElements(&quot;アイウエオ&quot;)   // 5
countElements(&quot;ア\u{20DD}&quot;)  // 1
</code></pre>

<blockquote>
<p>CocoaのNSStringは、lengthプロパティで長さを取得できますが、これはUTF16文字列の16ビットコードの長さを元に算出しているため、書記素クラスタによる装飾を反映できない場合があります。そのため、同じ文字列であっても、SwiftのcountElements(&hellip;)で返される値と、NSStringのlengthプロパティの値は一致しない可能性があります。（文字数という意味ではSwiftのStringの方が正確です。）</p>
</blockquote>

<p><strong>文字列のエンコード</strong></p>

<p>Swiftの文字列は、　ユニコードのUTF-8、UTF-16、UTF-32の各表現形式へエンコードできます。</p>

<p>UTF-8形式は、Stringのutf8プロパティで取得できます。</p>

<pre><code>let str = &quot;I \u{1F496} caf\u{E9}&quot;   // I heart.png café
for c in str.utf8 {
    print(NSString(format: &quot;%2X&quot;, c)); print(&quot; &quot;)
}
// 49 20 F0 9F 92 96 20 63 61 66 C3 A9
//
// 0x49 = &quot;I&quot;
// 0x20 = &quot; &quot;
// 0xF0 0x9F 0x92 0x96 = &quot;heart.png&quot;
// 0x20 = &quot; &quot;
// 0x63 = &quot;c&quot;
// 0x61 = &quot;a&quot;
// 0x66 = &quot;f&quot;
// 0xC3 0xA9 = &quot;é&quot;
</code></pre>

<p>UTF-16形式は、Stringのutf16プロパティで取得できます。</p>

<pre><code>let str = &quot;I \u{1F496} caf\u{E9}&quot;   // I heart.png café
for c in str.utf16 {
    print(NSString(format: &quot;%04X&quot;, c)); print(&quot; &quot;)
}
// 0049 0020 D83D DC96 0020 0063 0061 0066 00E9
//
// 0x0049 = &quot;I&quot;
// 0x0020 = &quot; &quot;
// 0xD83D 0xDC906 = &quot;heart.png&quot;
// 0x0020 = &quot; &quot;
// 0x0063 = &quot;c&quot;
// 0x0061 = &quot;a&quot;
// 0x0066 = &quot;f&quot;
// 0x00E9 = &quot;é&quot;
</code></pre>

<p>UTF-32形式は、21ビットのスカラー値をそのまま32ビットで表現した形式です。StringのunicodeScalarsプロパティで取得できます。</p>

<pre><code>let str = &quot;I \u{1F496} caf\u{E9}&quot;   // I heart.png café
for c in str.unicodeScalars {
    print(NSString(format: &quot;%08X&quot;, c.value)); print(&quot; &quot;)
}
// 00000049 00000020 0001F496 00000020 00000063 00000061 00000066 000000E9
//
// 0x00000049 = &quot;I&quot;
// 0x00000020 = &quot; &quot;
// 0x0001F496 = &quot;heart.png&quot;
// 0x00000020 = &quot; &quot;
// 0x00000063 = &quot;c&quot;
// 0x00000061 = &quot;a&quot;
// 0x00000066 = &quot;f&quot;
// 0x000000E9 = &quot;é&quot;
</code></pre>

<p><strong>UnicodeScalar</strong></p>

<p>UnicodeScalarは、ユニコードの1文字を表現する構造体です。次の例ではASCII値から文字を生成し、&rdquo;A&rdquo;〜&rdquo;Z&rdquo;の文字を連結しています。</p>

<pre><code>var str: String = &quot;&quot;
for ch in 65..&lt;(65 + 26) {
    str += Character(UnicodeScalar(ch))
}
print(str)    // ABCDEFGHIJKLMNOPQRSTUVWXYZ
</code></pre>

<h3 id="タプル">タプル</h3>

<p>タプルは、複数の値を一組にしたものです。配列と似ていますが、配列と違って異なる型の値をまとめることができます。但し、後から要素を追加したり削除することはできません。</p>

<blockquote>
<p>配列にも異なる型を入れることができますが、その場合、各要素の型はAnyやAnyObjectとなり、各要素を演算等で使用する場合にキャスト（型変換）が必要になります。タプルの要素はそのまま演算にも使用することができます。</p>
</blockquote>

<p>タプルは次の様に各要素を,（カンマ）区切りで並べ、&rdquo;(&ldquo;と&rdquo;)&ldquo;で括って記述します。値を参照する時は変数名の後に頭から順に0から始まる番号をつけます。</p>

<pre><code>let item = (&quot;ジュース&quot;, 100, 0.08, 108)
print(&quot;商品名=\(item.0), 税抜き価格=\(item.1)円, 消費税=\(item.2 * 100)%, 税込み価格=\(item.3)円&quot;)
// 商品名=ジュース, 税抜き価格=100円, 消費税=8.0%, 税込み価格=108円
</code></pre>

<p>タプルの各要素を別々の変数に受け取ることもできます。</p>

<pre><code>let (name, price, tax, priceWithTax) = (&quot;ジュース&quot;, 100, 0.08, 108)
print(&quot;商品名=\(name), 税抜き価格=\(price)円, 消費税=\(tax * 100)%, 税込み価格=\(priceWithTax)円&quot;)
</code></pre>

<p>次の様にタプルにラベルをつけて参照することもできます。</p>

<pre><code>let item = (name:&quot;ジュース&quot;, price:100, tax:0.08, priceWithTax:108)
print(&quot;商品名=\(item.name), 税抜き価格=\(item.price)円, 消費税=\(item.tax * 100)%, 税込み価格=\(item.priceWithTax)円&quot;)
</code></pre>

<h3 id="配列">配列</h3>

<h4 id="宣言">宣言</h4>

<p>Swiftの配列には要素の型を指定できます。配列は、&rdquo;[&ldquo;と&rdquo;]&ldquo;の間に型名を挟んで宣言します。また要素を参照するには、インデックス（0〜）を&rdquo;[&ldquo;と&rdquo;]&ldquo;で囲って指定します。</p>

<pre><code>let party: [String] = [&quot;勇者&quot;, &quot;戦士&quot;, &quot;魔法使い&quot;, &quot;僧侶&quot;]
print(party[2])   // 魔法使い
let hitPoints: [Int] = [140, 210, 85, 52]
print(hitPoints[1]) // 210
</code></pre>

<h3 id="ディクショナリ">ディクショナリ</h3>

<p>ディクショナリは、文字列や数値をキーにして値を格納したり参照できる型です。</p>

<p>宣言
ディクショナリは次のように、「[」と「]」の間に「:」（コロン）で区切ったキーと値のペアを「,」（カンマ）区切りで記述して初期化できます。</p>

<pre><code>let party: Dictionary&lt;String, String&gt; = [&quot;ルフィ&quot;: &quot;船長&quot;, &quot;ゾロ&quot;: &quot;剣士&quot;, &quot;ナミ&quot;:&quot;航海士&quot;]
if let job = party[&quot;ゾロ&quot;] {
    print(job)      // 剣士
}
let items: Dictionary&lt;String, Int&gt; = [&quot;りんご&quot;: 100, &quot;みかん&quot;: 300, &quot;バナナ&quot;: 150]
if let price = items[&quot;みかん&quot;] {
    print(price)    // 300
}
</code></pre>

<p>次のように、「[」と「]」の間に「:」（コロン）で区切ってキーと値の型を指定することもできます。</p>

<pre><code>let party: [String: String] = [&quot;ルフィ&quot;: &quot;船長&quot;, &quot;ゾロ&quot;: &quot;剣士&quot;, &quot;ナミ&quot;:&quot;航海士&quot;]
let items: [String: Int] = [&quot;りんご&quot;: 100, &quot;みかん&quot;: 300, &quot;バナナ&quot;: 150]
</code></pre>

<p>初期値を与える場合は要素から型が推測されるので型の明示は不要です。</p>

<pre><code>let party = [&quot;ルフィ&quot;: &quot;船長&quot;, &quot;ゾロ&quot;: &quot;剣士&quot;, &quot;ナミ&quot;: &quot;航海士&quot;]
let items = [&quot;りんご&quot;: 100, &quot;みかん&quot;: 300, &quot;バナナ&quot;: 150]
</code></pre>

<p>空のディクショナリは次の様に宣言できます。</p>

<pre><code>// キーがString型、値がString型のディクショナリ
var party: Dictionary&lt;String, String&gt; = [:]
// 又は
var party: [String: String] = [:]
// 又は
var party = Dictionary&lt;String, String&gt;()
// 又は
var party = [String: String]()

// キーがString型、値がInt型のディクショナリ
var items: Dictionary&lt;String, Int&gt; = [:]
// 又は
var items: [String: Int] = [:]
// 又は
var items = Dictionary&lt;String, Int&gt;()
// 又は
var items = [String: Int]()
</code></pre>

<h2 id="オプショナル型">オプショナル型</h2>

<p>オプショナル型とは、変数の型がもつ通常の値に加えて、空の（値が無い）状態を保持できる変数です。空の状態はnilで表現します。</p>

<blockquote>
<p>Apple社のSwiftの解説では、&rdquo;optional type&rdquo;、又は、&rdquo;optional value&rdquo;と書かれています。ここではオプショナル型としていますが、公式な呼び方ではありません。</p>
</blockquote>

<h3 id="宣言-1">宣言</h3>

<p>オプショナル型は、変数の宣言時に、型の後ろに「?」をつけて宣言します。</p>

<pre><code>var name: String?
name = nil

// オプショナル型でない変数にはnilを代入できない。
var name: String
name = nil  // エラーになる。
</code></pre>

<blockquote>
<p>オプショナル型は宣言時に値を代入しない場合は自動的にnilの値が設定されています。そのため宣言時にnilで初期化する必要はありません。</p>
</blockquote>

<h3 id="オプショナルバインディング">オプショナルバインディング</h3>

<p>オプショナル型は、次の様にif文の条件で使用することができます。値が空（nil）の場合はfalse、それ以外はtrueと判定されます。</p>

<pre><code>var price: Int? = 100
if let p = price {
    print(&quot;価格：\(p)円&quot;)
} else {
    print(&quot;価格：未定&quot;)
}
var price: Int? = 100

if var p = price {
    p -= 10
    print(&quot;割引価格：\(p)円&quot;)
}
</code></pre>

<p>これをオプショナルバインディングと呼びます。</p>

<h3 id="アンラップ">アンラップ</h3>

<p>オプショナル型を計算で使用したり、通常の型を受け取る関数の引数に渡したりする場合は、値が空でないことを明示するために、アンラップする必要があります。アンラップはラップ（包装）の反対で、オプションという包装紙に包まれた変数の包装を解くイメージです。</p>

<p>アンラップするには、オプショナル型の変数名の後ろに「!」をつけます。</p>

<pre><code>var price: Int?
price = 300
println(&quot;税込み価格は\(Int(Double(price!) * 1.08))円&quot;)   // 変数名の後ろに!をつけてアンラップ

// 非オプショナル型を受けとるには関数の呼び出し側でアンラップが必要
func calculateTax(price: Int) -&gt; Int {
    return Int(Double(price) * 1.08)
}
var price: Int?
price = 300
let priceWithTax = calculateTax(price!)
</code></pre>

<blockquote>
<p>中身が空（nil）のオプショナル型の変数をアンラップすると実行時エラーが発生します。</p>
</blockquote>

<pre><code>var price: Int?
println(&quot;価格は\(price!)円&quot;)   // エラー
</code></pre>

<p>if文を使うと、値が空かどうかの判定とアンラップされた別変数への代入を同時に行うことができます。</p>

<pre><code>var price: Double?
:
if let unwrappedPrice = price {
    // unwrappedPriceはアンラップされているので後ろに!は不要
    println(&quot;税込み価格は\(Int(unwrappedPrice * 1.08))円&quot;)
} else {
    println(&quot;価格は未定&quot;)
}
</code></pre>

<blockquote>
<p>if文の条件には結果がBool型となる条件しか書けませんが、上の書き方の場合、オプショナル型の変数が空の場合false、値が入っている場合trueと判定されif文で使用することができます。値が0の場合でも空（nil）ではないのでtrueと判定されます。</p>
</blockquote>

<p>定数でなく変数を使っても同様に書けます。</p>

<pre><code>var price: Double?
:
if var unwrappedPrice = price {
    unwrappedPrice *= 1.08
    println(&quot;税込み価格は\(Int(unwrappedPrice))円&quot;)
} else {
    println(&quot;価格は未定&quot;)
}
</code></pre>

<p>配列やディクショナリも同様にオプショナル型として宣言できます。</p>

<pre><code>var party: Array&lt;String&gt;?
party = [&quot;戦士&quot;, &quot;魔法使い&quot;]
party!.append(&quot;僧侶&quot;)

var items: Dictionary&lt;String, Int&gt;?
items = [&quot;りんご&quot;: 100, &quot;みかん&quot;: 300]
items![&quot;いちご&quot;] = 350
</code></pre>

<h3 id="暗黙的なオプショナル型">暗黙的なオプショナル型</h3>

<p>オプショナル型にはもう１つの宣言の仕方があります。暗黙的なオプショナル型と呼ばれるもので、宣言時に?ではなく!をつけて宣言します。</p>

<pre><code>var name: String!
</code></pre>

<p>暗黙的なオプショナル型は、空値（nil）をとり得るという意味では、上で説明したオプショナル型と同じですが、使用時にアンラップする必要がありません。</p>

<p>アンラップの必要がないので、初期値がnilでも使用時までには必ず値が入っていると想定されるケースでは、暗黙的なオプショナル型の方が便利です。</p>

<p>但し、アンラップが必要な状況で、暗黙的なオプショナル型を空のまま使用すると実行時エラーが発生します。</p>

<pre><code>var price: Double!
price = 300
println(&quot;税込み価格は\(Int(price * 1.08))円&quot;)   // 変数名の後ろに!をつける必要がない
price = nil
println(&quot;税込み価格は\(Int(price * 1.08))円&quot;)   // エラー
</code></pre>

<blockquote>
<p>暗黙的なオプショナル型の宣言に使用する!と、アンラップに使用する!を混同しないようにしてください。同じ記号が使われていますが意味は異なります。</p>
</blockquote>

<p>暗黙的なオプショナル型もif文の中で条件として使用することができます。</p>

<pre><code>var price: Double!
price = 100
if let unwrappedPrice = price {
    println(&quot;税込み価格は\(Int(unwrappedPrice * 1.08))円&quot;)
} else {
    println(&quot;価格は未定&quot;)
}
</code></pre>

<blockquote>
<p>暗黙的なオプショナル型は、Cocoaのクラスやプロトコルのメソッド宣言等で多用されています。例えば、UITableViewDataSouceでは次のようなメソッドが宣言されています。</p>
</blockquote>

<pre><code>func tableView(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!) -&gt; UITableViewCell!
</code></pre>

<h3 id="nil結合演算子">nil結合演算子</h3>

<p>??という演算子を使うと、オプショナル型がnilでなければその値を、nilの場合は指定した値を与えることができます。
次の様に使用します。</p>

<pre><code>var a: Int?
let b = a ?? 10 // aはnilなので、10が代入される

var s: String? = &quot;Hello&quot;
println(s ?? &quot;Bye&quot;) //  sはnilでないので、その値(Hello)が出力される
</code></pre>

<h2 id="タイプエイリアス">タイプエイリアス</h2>

<p>タイプエイリアスとは、型の別名定義のことです。</p>

<pre><code>typealias Money = Int
let m: Money = 100
print(m)  // 100

typealias BodyStatus = (String, Double)
var height:BodyStatus?
var weight:BodyStatus?

height = (&quot;身長&quot;, 170.0)
weight = (&quot;体重&quot;, 63.5)
</code></pre>

<h2 id="列挙型">列挙型</h2>

<h3 id="宣言-2">宣言</h3>

<p>列挙型は、関連する値を型としてまとめたものです。例えば、次のように信号機の状態をまとめることができます。</p>

<pre><code>// 信号機
enum Signal {
    case Blue       // 青
    case Yellow     // 黄   
    case Red        // 赤
}

var s: Signal
s = Signal.Blue
s = .Blue   // 型（Signal）は省略できる。
</code></pre>

<blockquote>
<p>列挙型の型名とメンバ名の最初の文字は大文字にすることが推奨されています。</p>
</blockquote>

<p>各メンバは次のように1行で書く事もできます。</p>

<pre><code>enum Signal {
    case Blue, Yellow, Red
}
</code></pre>

<p>列挙型の内部表現の型を次の様に明示的に指定することもできます。</p>

<pre><code>enum Signal: Int {
    case Blue
    case Yellow
    case Red
}
let s = Signal.Yellow
// toRawメソッドで実際の値を参照可能
print(s.toRaw())  // 1
// fromRawメソッドで値を設定可能
let signal = Signal.fromRaw(2)  // Signal.Red
</code></pre>

<blockquote>
<p>上で使っているfromRawメソッドはSignal型に無い値を渡した場合は、nilが返ります。つまり返り値はオプショナル型になります。上の場合は、signal: Signal? = Signal.fromRaw(2) と書くのと同義です。</p>
</blockquote>

<p>また、それぞれの値を必要に応じて指定することもできます。</p>

<pre><code>enum Signal: Int {
    case Blue = 1   // 1
    case Yellow     // 2
    case Red        // 3
}

// 整数型以外の場合は全ての値を明示する必要がある。
enum Signal: String {
    case Blue = &quot;青&quot;
    case Yellow = &quot;黄&quot;
    case Red = &quot;赤&quot;
}
</code></pre>

<p>列挙型にメソッドを定義することもできます。</p>

<pre><code>enum Signal {
    case Blue
    case Yellow
    case Red
    func meaning() -&gt; String {
        switch(self) {
        case .Blue:
            return &quot;進め&quot;
        case .Yellow:
            return &quot;注意&quot;
        case .Red:
            return &quot;止れ&quot;
        }
    }
}

let s = Signal.Yellow
print(s.meaning())    // 注意
</code></pre>

<h3 id="関連値">関連値</h3>

<p>Swiftの列挙型は、値を列挙する他に、別の型を使って表現することもできます。</p>

<pre><code>/* 乗り物 */
enum Vehicle {
    case Bicycle         // 自転車
    case Motorbike(Int)  // バイク（排気量）
    case Car(Int, Bool)  // 車（排気量, オートマ）
}

var vehicle = Vehicle.Bicycle
vehicle = .Motorbike(750)
vehicle = .Car(1600, true)

switch vehicle {
case .Bicycle:
    print(&quot;自転車&quot;)
case .Motorbike(let engine) where engine &lt;= 50:
    print(&quot;オートバイ:原付&quot;)
case .Motorbike(let engine) where engine &lt;= 125:
    print(&quot;オートバイ:小型&quot;)
case .Motorbike(let engine) where engine &lt;= 400:
    print(&quot;オートバイ:中型&quot;)
case .Motorbike(let engine):
    print(&quot;オートバイ:大型&quot;)
case .Car(let engine, let automatic) where engine &lt;= 660:
    print(&quot;軽自動車:&quot; + (automatic ? &quot;オートマ&quot; : &quot;マニュアル&quot;))
case .Car(let engine, let automatic):
    print(&quot;普通車 \(engine)cc:&quot; + (automatic ? &quot;オートマ&quot; : &quot;マニュアル&quot;))
}
</code></pre>

<h2 id="制御文">制御文</h2>

<p>Swiftの制御文には他の一般的な言語と同様、if、for、while、switch等があります。</p>

<h3 id="if">if</h3>

<p>if文は次のような構造になります。</p>

<pre><code>if 条件1 {
    条件1がtrueの場合に実行する処理
} else if 条件2 {
    条件2がtrueの場合に実行する処理
  :
} else {
    上のどの条件にも合致しなかった場合に実行する処理
}
</code></pre>

<p>if文の条件はtrueかflaseを返すBool型でなければなりません。Int型や文字列型等はif文の条件として直接使用することはできません。</p>

<p>{と}は必須です。else以降は不要なら省略できます。条件の前後を(と)で囲む必要はありませんが、囲むこともできます。</p>

<pre><code>var engine: Int?  // 排気量

if engine &lt;= 50 {
    print(&quot;原付バイク&quot;)
} else if engine &lt;= 125 {
    print(&quot;小型バイク&quot;)
} else if engine &lt;= 400 {
    print(&quot;中型バイク&quot;)
} else {
    print(&quot;大型バイク&quot;)
}

if engine == 750 {
    print(&quot;ナナハン&quot;)
}
</code></pre>

<blockquote>
<p>Swiftの論理演算は短絡評価です。例えば、Boolを返す次のようなfuncA()とfuncB()という関数を呼び出すif文があった場合、次の例では、funcA()の評価がfalseなので、if分の条件が偽となり、funcB()は実行されません。</p>
</blockquote>

<pre><code>func funcA() -&gt; Bool {
    print(&quot;funcA&quot;)
    return false
}
func funcB() -&gt; Bool {
    print(&quot;funcB&quot;)
    return true
}
if funcA() &amp;&amp; funcB() {
    // 実行されない
}
</code></pre>

<p>また、同様に、次の例では、funcA()からtrueが返された時点でif文の条件が真となり、funcB()は実行されません。</p>

<pre><code>func funcA() -&gt; Bool {
    print(&quot;funcA&quot;)
    return true
}

func funcB() -&gt; Bool {
    print(&quot;funcB&quot;)
    return false
}

if funcA() || funcB() {
    // 実行される
}
</code></pre>

<p>funcA()やfuncB()の中で副作用のある処理（クラスのメンバ変数やグローパル変数の書き換え等）を行うと結果が推測しにくくなるので、そのような書き方は避けるべきです。</p>

<h3 id="for">for</h3>

<p>for文には２通りの書き方があります。</p>

<p>1つは、C言語と似た書き方で、初期処理、ループの継続条件、ループの後処理を書く書き方です。</p>

<pre><code>for 初期処理; ループの継続条件; ループの後処理 {
    処理
}
</code></pre>

<p>ループの継続条件がtrueの間、ループが実行されます。通常、初期処理ではループ変数の初期化を行い、ループの後処理で変数のインクリメント等を行います。</p>

<pre><code>let party = [&quot;勇者&quot;, &quot;戦士&quot;, &quot;魔法使い&quot;, &quot;僧侶&quot;]
for var index = 0; index &lt; party.count; ++index {
    print(party[index])
}
</code></pre>

<p>ループの中でcontinueを使うと途中で次のループ処理へ移ることができます。また同様にbreakを使うと処理を中断してループを抜けることができます。</p>

<pre><code>let party = [&quot;勇者&quot;, &quot;戦士&quot;, &quot;魔法使い&quot;, &quot;僧侶&quot;]
for var index = 0; index &lt; party.count; ++index {
    if index &lt; 1 { continue }
    if index &gt; 2 { break }
    print(party[index])
}
/*
戦士
魔法使い
*/
</code></pre>

<p>上のindexは、forループの中でのみ参照可能です。forループの外で参照するには、次のようにループの外側で変数を宣言する必要があります。</p>

<pre><code>let party = [&quot;勇者&quot;, &quot;戦士&quot;, &quot;魔法使い&quot;, &quot;僧侶&quot;]
var index: Int
for index = 0; index &lt; party.count; ++index {
    if index &lt; 1 { continue }
    if index &gt; 2 { break }
    print(party[index])
}
print(&quot;index=\(index)&quot;)
</code></pre>

<p>もう1つのfor文の書き方は、for 〜 in を使った書き方です。</p>

<pre><code>for 要素 in 要素の取り出し元 {
    処理
}
</code></pre>

<p>次のように範囲演算子と共に使うことができます。for の後の変数は定数となります。letは不要です。但しforループの外で参照することはできません。</p>

<pre><code>for index in 1...5 {
    // indexは定数
    print(&quot;index = \(index)&quot;)
}
/* 実行結果
index = 1
index = 2
index = 3
index = 4
index = 5
*/
</code></pre>

<pre><code>let party = [&quot;勇者&quot;, &quot;戦士&quot;, &quot;魔法使い&quot;, &quot;僧侶&quot;]
for index in 0 ..&lt; party.count {
    print(party[index])
}
/* 実行結果
勇者
戦士
魔法使い
僧侶
*/
</code></pre>

<p>要素を使用しない場合は、_（下線）で置き換えることができます。</p>

<pre><code>for _ in 0 ..&lt; party.count {
    print(&quot;Hello&quot;)
}
</code></pre>

<p>配列やディクショナリはfor〜inを使ってループ処理することができます。</p>

<pre><code>let party = [&quot;勇者&quot;, &quot;戦士&quot;, &quot;魔法使い&quot;, &quot;僧侶&quot;]
for chara in party {
    print(chara)
}

let items = [&quot;りんご&quot;: 100, &quot;みかん&quot;: 300, &quot;バナナ&quot;: 150]
// ディクショナリの場合は、キーと値のペアのタプルが取り出される
for (name, price) in items {
    print(&quot;\(name): \(price)円&quot;)
}
// 1つの変数に受け取ることも可能
for item in items {
    print(&quot;\(item.0): \(item.1)円&quot;)
}
</code></pre>

<p>こちらも、使用しない要素は_（下線）にできます。</p>

<pre><code>let items = [&quot;りんご&quot;: 100, &quot;みかん&quot;: 300, &quot;バナナ&quot;: 150]
for (name, _) in items {
    print(name)
}
</code></pre>

<h3 id="while">while</h3>

<p>while文には、ループの最初で条件を判定する書き方と、ループの最後で条件を判定する書き方があります。</p>

<p>ループの最初で判定する書き方は次のようになります。</p>

<pre><code>while ループの継続条件 {
    処理
}
</code></pre>

<pre><code>/*
  戦闘関数
  自分のダメージと相手のダメージをタプルで返す
*/
func fight() -&gt; (Int, Int) {
    var myDamage: Int       // 自分のダメージ
    var enemyDamage: Int    // 相手のダメージ
    :
    return (myDamage, enemyDamage)
}

var myHitPoint: Int     // 自分のHP
var enemyHitPoint: Int  // 相手のHP
// 戦闘処理
while 0 &lt; myHitPoint &amp;&amp; 0 &lt; enemyHitPoint {
    let (myDamage, enemyDamage) = fight()
    print(&quot;敵に\(enemyDamage)のダメージを与えた。&quot;)
    print(&quot;\(myDamage)のダメージを受けた。&quot;)
    myHitPoint -= myDamage
    enemyHitPoint -= enemyDamage
}
</code></pre>

<p>for文と同様に、continueやbreakで処理の継続や中断ができます。</p>

<pre><code>while 0 &lt; myHitPoint {
    let (myDamage, enemyDamage) = fight()
    print(&quot;敵に\(enemyDamage)のダメージを与えた。&quot;)
    if enemyHitPoint - enemyDamage &lt; 0 {
        print(&quot;あなたの勝ち！&quot;)
        break
    }
    print(&quot;\(myDamage)のダメージを受けた。&quot;)
    myHitPoint -= myDamage
    enemyHitPoint -= enemyDamage
}
</code></pre>

<p>ループの最後に判定する書き方は次のようになります。</p>

<pre><code>do {
    処理
} ループの継続条件
</code></pre>

<p>ループの最初に判定する書き方の場合、条件によってはループの中の処理が一回も実行されない場合がありますが、ループの最後に判定する書き方の場合、ループの中の処理が最低１回は実行されます。</p>

<pre><code>do {
    let (myDamage, enemyDamage) = fight()
    print(&quot;敵に\(enemyDamage)のダメージを与えた。&quot;)
    print(&quot;\(myDamage)のダメージを受けた。&quot;)
    myHitPoint -= myDamage
    enemyHitPoint -= enemyDamage
} while 0 &lt; myHitPoint &amp;&amp; 0 &lt; enemyHitPoint
</code></pre>

<p>forやwhileの前にラベルを書いて、continueやbreakの対象として指定することができます。内側のループから外側のループへ戻す場合に便利です。</p>

<pre><code>let text: String = &quot;「りんご」 「みかん」 「バナナ」&quot;
// 「 と 」で括られた文字列の切り出し
outerLoop: for var index = text.startIndex; index != text.endIndex; index = index.successor() {
    var ch = text[index]
    if ch == &quot;「&quot; {
        var fruit = &quot;&quot;
        while true {
            index = index.successor()
            if index == text.endIndex {
                break outerLoop
            }
            ch = text[index]
            if ch == &quot;」&quot; {
                print(fruit)
                continue outerLoop
            }
            fruit += ch
        }
    }
}
/*
りんご
みかん
バナナ
*/
</code></pre>

<h3 id="switch">switch</h3>

<p>switch文を使うと、値に応じた処理内容を記述することができます。値のパターンが多い場合、if文を使うより見通しよく書けます。C言語やJavaのswitch文と似ていますが、Swiftのswitch文はより柔軟な比較判定が可能です。</p>

<p>switch文の基本的な構造は次のようになります。</p>

<pre><code>switch 比較対象（変数や関数の戻り値等） {
case 値1:
    値1に合致する場合の処理
case 値2, 値3:
    値2又は値3に合致する場合の処理
  :
default:
    上のどの条件にも合致しなかった場合の処理
}
</code></pre>

<p>switchに比較する対象となる要素を書き、想定する値の条件をcaseに書きます。</p>

<pre><code>var coin: Int  // 硬貨（円）
  :
switch coin {
case 1, 10, 100:
    print(&quot;穴無し硬貨&quot;)
case 5, 50:
    print(&quot;穴開き硬貨&quot;)
default:
    print(&quot;不明&quot;)
}
</code></pre>

<p>C言語のswitchと異なり、caseの最後にbreakを書く必要はありません。逆に複数のcaseで同じ処理をしたい場合は、次へ移るcaseの最後にfallthrough と書きます。</p>

<pre><code>var coin: Int // 硬貨（円）
  :
switch coin {
case 1:
    fallthrough
case 10:
    fallthrough
case 100:
    print(&quot;穴無し硬貨&quot;)
case 5:
    fallthrough
case 50:
    print(&quot;穴開き硬貨&quot;)
default:
    print(&quot;不明&quot;)
}
</code></pre>

<p>数値以外の型も比較対象として使用することができます。</p>

<pre><code>var signal: String  // 信号機
:
switch signal {
case &quot;青&quot;:
    print(&quot;進め&quot;)
case &quot;黄&quot;:
    print(&quot;注意&quot;)
case &quot;赤&quot;:
    print(&quot;止れ&quot;)
default:
    print(&quot;故障？&quot;)
}
</code></pre>

<p>比較対象が取り得る全ての値をcaseに網羅する必要があります。抜けがあるとコンパイルエラーになります。上の例では、Int型もString型もcaseに記述された以外の値も取り得るので、default:の記述が無いとエラーになります。</p>

<p>次の様にenum型の判定にも使用することができます。この場合、全ての値を網羅できているのでdefault:は不要です。</p>

<pre><code>// 信号機
enum Signal {
    case Blue   // 青
    case Yellow // 黄
    case Red    // 赤
}
var s: Signal
  :
switch s {
case .Blue:
    print(&quot;進め&quot;)
case .Yellow:
    print(&quot;注意&quot;)
case .Red:
    print(&quot;止れ&quot;)
}
</code></pre>

<p>caseに何も処理が記述されていないとエラーになります。</p>

<pre><code>switch s {
case .Blue:
    print(&quot;進め&quot;)
case .Yellow:
    /* エラー */
case .Red:
    print(&quot;止れ&quot;)
}
</code></pre>

<p>何も処理したくない場合は、breakだけ記述します。</p>

<pre><code>switch s {
case .Blue:
    print(&quot;進め&quot;)
case .Yellow:
    break
case .Red:
    print(&quot;止れ&quot;)
}
</code></pre>

<p>次の様にcaseで範囲を指定することもできます。</p>

<pre><code>var num: Int
  :
switch abs(num) {   // absは絶対値を返す関数
case 0:
    print(&quot;ゼロ&quot;)
case 1..&lt;10:
    print(&quot;1桁&quot;)
case 10..&lt;100:
    print(&quot;2桁&quot;)
case 100..&lt;1000:
    print(&quot;3桁&quot;)
default:
    print(&quot;4桁以上&quot;)
}
</code></pre>

<p>whileを使って条件を指定することもできます。</p>

<pre><code>switch abs(num) {   // absは絶対値を返す関数
case let n where n == 0:
    print(&quot;ゼロ&quot;)
case let n where n &lt; 10:
    print(&quot;1桁&quot;)
case let n where n &lt; 100:
    print(&quot;2桁&quot;)
case let n where n &lt; 1000:
    print(&quot;3桁&quot;)
default:
    print(&quot;4桁以上&quot;)
}
</code></pre>

<p>複数のcaseに該当する場合、上から順に評価されて最初に該当するcaseの内容が実行され、それ以降の該当するcaseの内容は実行されません。</p>

<pre><code>var i = 10

switch i {
case let j where j &lt; 10:
    print(&quot;i &lt; 10&quot;)
case let j where j &lt; 100:
    print(&quot;i &lt; 100&quot;)     // ここの内容だけ実行される
case let j where j &lt; 1000:
    print(&quot;i &lt; 1000&quot;)
default:
    print(&quot;i &lt;= 1000&quot;)
}
/*
 実行結果
 i &lt; 100
*/
</code></pre>

<p>次はタプルをswitch文で判定する例です。</p>

<pre><code>var vehicle: (Int, Int?) // タイヤの数と排気量
vehicle = (2, 125)

switch vehicle {
case (1, _):      // 不要な変数は_（下線）を指定して無視
    print(&quot;一輪車&quot;)
case (2, nil):
    print(&quot;自転車&quot;)
case let (2, engine):
    switch engine! {
    case let e where e &lt;= 0:
        print(&quot;バイク:排気量エラー&quot;)
    case 1...50:
        print(&quot;原付バイク&quot;)
    case 51...125:
        print(&quot;小型バイク&quot;)
    case 126...250:
        print(&quot;中型バイク&quot;)
    default:
        print(&quot;大型バイク&quot;)
    }
case (3, _):
    print(&quot;三輪車&quot;)
case let (4, engine) where engine != nil:
    switch engine! {
    case let e where e &lt;= 0:
        print(&quot;自動車:排気量エラー&quot;)
    case let e where e &lt;= 660:
        print(&quot;軽自動車&quot;)
    default:
        print(&quot;普通車&quot;)
    }
case let (tire, engine):
    print(&quot;不明な乗り物（\(tire)輪、排気量:&quot; + (engine == nil ? &quot;-&quot; : &quot;\(engine!)cc&quot;)  + &quot;）&quot;)
}
</code></pre>

<p>通常、caseの条件文にはletを使いますが、varを使って、値を変更することも可能です。</p>

<pre><code>let num: Int = 10

switch num {
case var n where n == 10:
    n += 20
    print(n)
default:
    break
}
</code></pre>

<h2 id="関数">関数</h2>

<h3 id="宣言-3">宣言</h3>

<p>Swiftの関数の構文は次のようになります。</p>

<pre><code>// String型とInt型の引数を受け取る関数
func showEncounterMessage(monster: String, count: Int) {
    print(&quot;\(count)匹の\(monster)が現れた！&quot;)
}
</code></pre>

<p>showEncounterMessage(&ldquo;スライム&rdquo;, 3) // 関数の呼び出し
funcの後に関数名を書き、( と )の間に引数名と型を必要な数だけ指定します。引数が不要な場合でも関数を呼び出す時には()は必要です。</p>

<p>戻り値を返す場合は、)の後に、-&gt; をつけて型を指定します。</p>

<pre><code>// String型とInt型の引数を受け取り、String型を返す関数
func getEncounterMessage(monster: String, count: Int) -&gt; String {
    return &quot;\(count)匹の\(monster)が現れた！&quot;
}
let message = getEncounterMessage(&quot;スライム&quot;, 3)
getEncounterMessage(&quot;ゴブリン&quot;, 1)  // 戻り値を受け取らなくてもエラーにはならない
</code></pre>

<p>タプルを戻り値とすることで複数の値を返すことができます。</p>

<pre><code>// 元号
enum Era {
    case Meiji, Taisho, Showa, Heisei
}
// 指定された元号の名前と開始年を返す
func getEraInfo(era: Era) -&gt; (name: String, startYear: Int) {
    switch era {
    case .Meiji:
        return (&quot;明治&quot;, 1868)
    case .Taisho:
        return (&quot;大正&quot;, 1912)
    case .Showa:
        return (&quot;昭和&quot;, 1926)
    case .Heisei:
        return (&quot;平成&quot;, 1989)
    }
}

let showa = getEraInfo(.Showa)
</code></pre>

<p>次のようにオプショナルな戻り値を返すこともできます。</p>

<pre><code>// 元号
enum Era {
    case Meiji, Taisho, Showa, Heisei, Unknown
}
// 指定された元号の名前と開始年を返す
func getEraInfo(era: Era) -&gt; (name: String, startYear: Int)? {
    switch era {
    case .Meiji:
        return (&quot;明治&quot;, 1868)
    case .Taisho:
        return (&quot;大正&quot;, 1912)
    case .Showa:
        return (&quot;昭和&quot;, 1926)
    case .Heisei:
        return (&quot;平成&quot;, 1989)
    case .Unknown:
        return nil
    }
}

if let era = getEraInfo(.Showa) {
    print(&quot;元号:\(era.name) 開始年:\(era.startYear)&quot;)
}
</code></pre>

<h3 id="外部引数名">外部引数名</h3>

<p>関数の各引数には、引数名（ローカル名）の他に、分かりやすいラベル（外部名）をつけて、呼び出し時に使うことができます。ラベルをつける事で関数自体がより説明的になり機能や意味が伝わりやすくなります。</p>

<pre><code>// RGB値を16進数文字列に変換
func rgbToString(red r:Int, green g:Int, blue b:Int) -&gt; String {
    // 関数内では、各引数のローカル名を使用
    return String(format:&quot;%02x%02x%02x&quot;, r, g, b)
}

let color = rgbToString(red: 255, green: 128, blue: 0)  // ff8000
</code></pre>

<h3 id="引数の規定値">引数の規定値</h3>

<p>関数の宣言時に引数にデフォルト（既定）値を与えることができます。</p>

<pre><code>func encloseText(text: String, prefix: String = &quot;(&quot;, suffix: String = &quot;)&quot;) -&gt; String {
    return prefix + text + suffix
}

print(encloseText(&quot;りんご&quot;)) // (りんご)
print(encloseText(&quot;りんご&quot;, prefix:&quot;【&quot;, suffix:&quot;】&quot;)) // 【りんご】
</code></pre>

<p>既定値の与えられた引数を省略した場合、指定された既定値が引数として使用されます。</p>

<p>既定値をもつ引数は、特に外部名を指定しなければ、ローカル名が外部名となり、呼び出し側で既定値と異なる値を渡す時にラベルとして使用することができます。（引数名の前に#をつける必要はありません）</p>

<p>外部名を使いたくない場合は、次のように_（下線）を指定して無効にすることができます。（推奨はされないようです）</p>

<pre><code>func encloseText(text: String, _ prefix: String = &quot;(&quot;, _ suffix: String = &quot;)&quot;) -&gt; String {
    return prefix + text + suffix
}

print(encloseText(&quot;みかん&quot;, &quot;[&quot;, &quot;]&quot;))   // [みかん]
</code></pre>

<p>引数の順番を次のようにすることも可能ですが、呼び出し方の一貫性を保つために、既定値付きの引数は引数リストの後方にもってくるように推奨されています。</p>

<pre><code>// 次の様な引数の並びは推奨されない。
func encloseText(prefix: String = &quot;(&quot;, suffix: String = &quot;)&quot;, text: String) -&gt; String {
    return prefix + text + suffix
}

print(encloseText(&quot;りんご&quot;)) // (りんご)
print(encloseText(prefix: &quot;[&quot;, suffix:&quot;]&quot;, &quot;りんご&quot;)) // [りんご]
</code></pre>

<h3 id="可変数個引数">可変数個引数</h3>

<p>Swiftでは同じ型の可変個の引数を渡すことができます。可変個の引数を受け取ることを示すには、型の後に&hellip;（ピリオドが3つ）を書きます。</p>

<p>関数の中では可変個引数は指定された型の配列として参照することができます。</p>

<pre><code>// 文字列中に指定した文字のどれかが含まれればtrueを返す
func containsCharacter(text: String, characters: Character...) -&gt; Bool {
    for ch in characters {
        for t in text {
            if ch == t {
                return true
            }
        }
    }
    return false
}

containsCharacter(&quot;abcdefg&quot;, &quot;i&quot;) // false
containsCharacter(&quot;abcdefg&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;) // true
</code></pre>

<p>可変数個引数は引数リストの最後に配置する必要があります。もし既定値と可変数個引数をもつ関数が必要な場合は、既定値をもつ引数の後に可変数個引数を配置するようにします。</p>

<pre><code>// 可変数個引数は引数の最後に
func someFunc(arg1: Int, arg2: String = &quot;hogehoge&quot;, arg3: Int...) {
    :
}
</code></pre>

<h3 id="定数引数と可変引数">定数引数と可変引数</h3>

<p>関数の引数はデフォルトで定数として渡されます。（letが省略されています。引数名の前にletをつけても構いません）関数の中で引数の値を変更しようとするとエラーになります。</p>

<pre><code>func printHelloMessage(text: String) {
    text = &quot;Hello、&quot; + text  // コンパイルエラー
    print(text);
}
</code></pre>

<p>引数名の前にvarをつけると、引数は可変変数となり、関数内での変更もできるようになります。但し、変更した引数の値を関数の外部で参照することはできません。</p>

<pre><code>func printHelloMessage(var text: String) {
    text = &quot;Hello、&quot; + text
    print(text);
}

printHelloMessage(&quot;Swift&quot;)  // Hello, Swift
</code></pre>

<p>引数名の前にinoutをつけると、引数として渡した可変変数を関数の中で変更して、変更後の値を関数の外側でも参照できるようになります。</p>

<p>関数の呼び出し時に、変数の前に&amp;をつけて呼び出します。また、ここで渡す変数は可変変数でなければなりません。定数を渡すとコンパイルエラーになります。
また、既定値をもつ引数や、可変数個引数にinout指定をすることはできません。varやletとinoutを同時に指定することもできません。</p>

<pre><code>func incrementBy(inc: Int, inout val1: Int, inout val2: Int) {
    val1 += inc
    val2 += inc
}

var val1 = 100
var val2 = 200
incrementBy(10, &amp;val1, &amp;val2)
print(&quot;val1=\(val1), val2=\(val2)&quot;)   // val1=110, val2=210
</code></pre>

<h3 id="関数型">関数型</h3>

<p>関数も他の型と同様、型情報を持ちます。
例えば次の関数は、2つのInt型を引数にとり、Int型を返す関数で、型は、(Int, Int) -&gt; Int となります。</p>

<pre><code>func multiply(val: Int, #by: Int) -&gt; Int {
    return val * by
}
</code></pre>

<p>次の関数の型は、(String, Int) -&gt; () となります。</p>

<pre><code>func showEncounterMessage(monster: String, count: Int) {
    print(&quot;\(count)匹の\(monster)が現れた！&quot;)
}
</code></pre>

<p>次の様に、関数型の変数を宣言し、関数名を代入して呼び出すことができます。</p>

<pre><code>var f: (Int, Int) -&gt; Int
f = multiply
var v = f(10, 3)    // 30 *ここでは外部名のbyは使えない
</code></pre>

<p>型推論が働くので、型を宣言しなくても代入することができます。但し、異なる型の関数を代入すると実行時エラーになります。</p>

<pre><code>var f = multiply
var v = f(10, by:3)    // 30
f = showEncounterMessage    // 異なる型の代入は実行時エラー
</code></pre>

<p>関数自体を、他の関数への引数として使うことができます。</p>

<pre><code>// 足し算
func add(a: Int, b: Int) -&gt; Int {
    return a + b
}

// 引き算
func subtract(a: Int, b: Int) -&gt; Int {
    return a - b
}

// 関数を渡して計算
func calculate(a: Int, b: Int, function:(Int, Int) -&gt; Int) -&gt; Int {
    return function(a, b)
}

calculate(10, 20, add)  // 30
let f = subtract
calculate(10, 20, f)    // -10
</code></pre>

<h3 id="無名関数">無名関数</h3>

<p>関数の内容を次のように、名前を持たない関数として直接記述して渡すこともできます。</p>

<pre><code>func calculate(a: Int, b: Int, function: (Int, Int) -&gt; Int) -&gt; Int {
    return function(a, b)
}

// 引数として乗算の結果を返す無名関数を記述
calculate(10, 20, {
    (val1: Int, val2: Int) in
    return val1 * val2
})
</code></pre>

<p>引数名と戻り値の型を書いて、in に続けて、関数の処理内容を記述します。</p>

<blockquote>
<p>無名関数の引数に既定値を与えることはできません。</p>
</blockquote>

<p>引数と戻り値の型は、関数の宣言から類推されるので次の様に型の指定を省くことができます。</p>

<pre><code>calculate(10, 20, {
    val1, val2 in
    return val1 * val2
})
</code></pre>

<p>さらに、無名関数の引数は上の例のように名前をつけなくても、第一引数から順に$0, $1&hellip;として参照できます。また値を返すだけの関数の場合、return文自体も省略できるので、上の例は次のように簡略化して書くこともできます。</p>

<pre><code>calculate(10, 20, { $0 * $1 })
</code></pre>

<p>さらにもう少し簡略化できます。Swiftでは、演算子も関数として実装されています。そして乗算に用いる * は、Int型同士を掛けてInt型を返す関数でもあるので、上の例ではそのまま渡すことができます。（*だけでなく、+、-、/、%等も同様です。）</p>

<pre><code>calculate(10, 20, *)    // 200
calculate(10, 20, +)    // 30
calculate(10, 20, -)    // -10
</code></pre>

<p>上の無名関数の例はさらに別の書き方があります。引数で渡す関数が引数リストの最後の引数の場合、次のように、関数名()の後の、{ }の中に処理内容を記述することができます。</p>

<pre><code>func calculate(a: Int, b: Int, function: (Int, Int) -&gt; Int) -&gt; Int {
    return function(a, b)
}

calculate(10, 20) {
    $0 * $1
}
</code></pre>

<p>引数が関数のみの場合は、関数名の後の()も不要です。</p>

<pre><code>func sayHello(greeting:(String) -&gt; String) -&gt; () {
    print(greeting(&quot;Hello&quot;))
}

sayHello { $0 + &quot;, World&quot; } // Hello, World
sayHello { &quot;Hi, &quot; + $0 }    // Hi, Hello
</code></pre>

<h3 id="関数のネスト">関数のネスト</h3>

<p>次のように、関数の内部で別の関数を定義して使うことができます。</p>

<pre><code>func addAndSubtract(val1: Int, val2: Int, val3:Int) -&gt; Int {
    // 足し算
    func add(a: Int, b: Int) -&gt; Int {
        return a + b
    }
    // 引き算
    func subtract(a: Int, b: Int) -&gt; Int {
        return a - b
    }

    var result = add(val1, val2)
    result = subtract(result, val3)
    return result
}

addAndSubtract(10, 50, 20)  // 40
</code></pre>

<h3 id="クロージャ">クロージャ</h3>

<p>関数を呼び出す側のスコープで定義された変数を、内側の関数で参照したり変更することができます。これはクロージャと呼ばれるものです。</p>

<pre><code>func calculate(val1: Int, val2: Int, val3:Int) -&gt; Int {
    var x: Int?

    func calc1(a: Int, b: Int) -&gt; Int {
        if x == nil {
            x = 100
        }
        return a + b
    }
    func calc2(a: Int, b: Int) -&gt; Int {
        return a - b + (x == nil ? 0 : x!)
    }

    var result = calc1(val1, val2)
    result = calc2(result, val3)
    return result
}

calculate(10, 50, 20)   // 140
</code></pre>

<p>クロージャを使うと例えば次のように、呼び出される度に+1した値を返す関数オブジェクトを生成することができます。</p>

<pre><code>func makeIncrementer(initValue: Int) -&gt; () -&gt; Int {
    var v = initValue
    func incrementer() -&gt; Int {
        return ++v
    }

    return incrementer
}

let inc = makeIncrementer(10)
inc()   // 11
inc()   // 12
inc()   // 13
</code></pre>

<p>次の例では、1ではなく引数（第２引数）で指定した値を加算するようにしています。このように外側の関数の引数も内部の関数で参照することができます。</p>

<pre><code>func makeIncrementer(initValue: Int, addValue: Int) -&gt; () -&gt; Int {
    var v = initValue
    func incrementer() -&gt; Int {
        v += addValue
        return v
    }

    return incrementer
}

let inc = makeIncrementer(10, 5)
inc()   // 15
inc()   // 20
inc()   // 25
</code></pre>

<p>上の引数initValueにvarを指定し、さらにネストした関数を無名関数にするともう少し簡潔に記述できます。</p>

<pre><code>func makeIncrementer(var initValue: Int, addValue: Int) -&gt; () -&gt; Int {
    return {
        initValue += addValue
        return initValue
    }
}

let inc = makeIncrementer(10, 5)
inc()   // 15
inc()   // 20
inc()   // 25
</code></pre>

<h2 id="クラス">クラス</h2>

<p>クラスはオブジェクト指向の根幹をなすもので、簡単に言うと変数と関数をまとめたものです。
Swiftでは、クラスは次の様に宣言します。</p>

<pre><code>/* モンスタークラス */
class Monster {
    var level = 1       // レベル
    var name: String?   // 名前
    // 説明
    func description() -&gt; String {
        if name == nil  {
            return &quot;不明 Lv.\(level)&quot;
        } else {
            return &quot;\(name!) Lv.\(level)&quot;
        }
    }
}
</code></pre>

<blockquote>
<p>Swiftのクラス定義はC++やObjective-Cのようにヘッダファイルと実装ファイルを分ける必要はありません。通常は１つのswiftファイルにクラスの定義と実装内容をまとめて記述します。
Swiftのクラス名は、次の様にアッパーキャメルケース（最初の文字とその後の区切りとなる単語の最初の文字は大文字）で記述することが推奨されています。また、プロパティやメソッドはローワーキャメルケース（最初の文字は小文字で、その後の区切りとなる単語の最初の文字は大文字）とすることが推奨されています。</p>
</blockquote>

<pre><code>/* プレイヤークラス */
class Player {
    var hitPoint: Int
    func attack() { ... }
    :
}

/* 銀行口座クラス */
class BankAccount {
   var amount: Int
   func depositMoney(money: Int) { ... }
   func withdrawMoney(money: Int) { ... }
    :
}
</code></pre>

<h3 id="インスタンスの生成">インスタンスの生成</h3>

<p>クラスはオブジェクトの内容を定義する設計図みたいなもので、実際に使用するには、クラスのインスタンス（オブジェクト）を生成する必要があります。
インスタンスを生成するには次のように、クラス名に()をつけて関数の様に呼び出します。</p>

<pre><code>var monsterA = Monster()
</code></pre>

<p>インスタンスを生成したら、メンバ変数（クラスの変数をメンバ変数と呼びます。他にインスタンス変数と呼ぶこともあります。またプロパティと呼ぶこともあります。Objective-Cではインスタンス変数とプロパティは別の意味で扱われますが、Swiftでは区別しません。）やメソッド（クラスの関数をメソッドと呼びます。）にアクセスできます。
これらインスタンスの属性には、インスタンス名の後に.（ドット）をつけてアクセスします。</p>

<pre><code>var monsterA = Monster()
print(monsterA.description()) // 不明 Lv.1
</code></pre>

<p>別のインスタンスを生成することもできます。</p>

<pre><code>var slime = Monster()
slime.name = &quot;スライム&quot;
print(slime.description()) // スライム Lv.1
</code></pre>

<p>クラスのインスタンスは、変数に代入するとインスタンスそのものではなく、その参照が代人されます。その変数を別の変数に代入すると、１つのインスタンスを２つの変数で参照することになります。（参照カウントが2になる。）
そのため、一方の変数のプロパティを変更すると、別の変数でそのプロパティにアクセスした時も変更された後の値が参照されます。</p>

<pre><code>var monsterA = Monster()       // インスタンスの生成
monsterA.name = &quot;スライム&quot;

var monsterB = monsterA        // 別の変数に代入
monsterB.name = &quot;ドラゴン&quot;      // プロパティを変更

// どちらのモンスター名も同じ
print(monsterA.description()) // ドラゴン Lv.1
print(monsterB.description()) // ドラゴン Lv.1
</code></pre>

<p>クラスのインスタンスは上でみたように参照渡し（値そのものではなく、インスタンスへのアドレスが渡される）です。定数にインスタンスを代入した場合、参照先のインスタンスを変更することはできませんが、参照しているインスタンスのプロパティ自体は変更可能です。（値渡しの構造体とは動作が異なります。）</p>

<pre><code>let monster = Monster()
slime.name = &quot;スライム&quot;    // 定数のプロパティを変更してもエラーにならない  
slime.name = &quot;ドラゴン&quot;    // エラーにならない
</code></pre>

<blockquote>
<p>クラスと異なり、構造体や列挙型は値渡しです。構造体のインスタンスを定数に代入した場合、プロパティは変更できません。</p>
</blockquote>

<h3 id="イニシャライザ">イニシャライザ</h3>

<p>インスタンスの生成時に必ず実行されるメソッドを定義して、その中で変数の初期化を行うことができます。このメソッドをイニシャライザ、又はコンストラクタと呼びます。
イニシャライザは、initという名前のメソッドです。但しメソッド名の前にfuncを書く必要はありません。</p>

<pre><code>/* モンスタークラス */
class Monster {
    var level = 1       // レベル
    let name: String    // 名前
    // イニシャライザ
    init() {
        self.name = &quot;不明&quot;
    }
    // 説明
    func description() -&gt; String {
        return &quot;\(name) Lv.\(level)&quot;
    }
}

let m = Monster()
print(m.description()) // 不明 Lv.1
</code></pre>

<p>selfは自分自身（インスタンス）を指し、そのインスタンスの属性であることを示すために使用しますが、上の場合はnameはメンバ変数であることが自明なので無くても構いません。</p>

<p>オプショナル型以外の変数は、上のように宣言時に値を設定するか、イニシャライザの中で初期値を与える必要があります。（初期値を与えないとコンパイルエラーになります。）</p>

<p>イニシャライザには次のように引数を与えることができます。引数はインスタンスの生成時に渡します。また、特に指定しない限りローカル引数名が外部名となります。</p>

<pre><code>/* モンスタークラス */
class Monster {
    var level: Int      // レベル
    let name: String    // 名前
    // イニシャライザ
    init(name: String, level: Int = 1) {
        self.name = name
        self.level = level
    }
    // 説明
    func description() -&gt; String {
        return &quot;\(name) Lv.\(level)&quot;
    }
}

let slimeA = Monster(name: &quot;スライム&quot;)
let slimeB = Monster(name: &quot;スライム&quot;, level: 5)
print(slimeA.description()) // スライム Lv.1
print(slimeB.description()) // スライム Lv.5
</code></pre>

<p>上の場合、メンバ変数の名前とイニシャライザの引数の名前が同じなので、selfを使ってメンバ変数と引数を区別する必要があります。（selfをつけないと優先的に引数と認識されます。）</p>

<h3 id="デイニシャライザ">デイニシャライザ</h3>

<p>生成されたインスタンスは、スコープを抜けたり、変数にnilや他のインスタンスが割り当てられるとメモリ上から破棄されます。この時、自動的に呼ばれるメソッドがあります。このメソッドのことをデイニシャライザ、又はデストラクタと呼びます。
デイニシャライザの中では必要に応じて、そのクラスで確保したリソースを破棄したり、開いたファイルを閉じる、通信を切断する等の後始末的な処理を記述します。
デイニシャライザは、deinitという名のメソッドです。deinitの後の()は不要です。引数を与えることはできません。</p>

<pre><code>class FileHandler {
    :
    handle: Int
    // イニシャライザ
    init() {
        :
        self.handle = open(...)
    }
    // デイニシャライザ
    deinit {
        close(self.handle)
    }
}
</code></pre>

<blockquote>
<p>メンバ変数はインスタンスが破棄される時に自動的に破棄されるので、デイニシャライザの中で明示的に破棄する必要はありません。</p>
</blockquote>

<h3 id="ゲッターとセッター">ゲッターとセッター</h3>

<p>メンバ変数としてなんらかの計算した値を返したり、メンバ変数を受け取る時になんらかの処理をすることができます。これらはそれぞれゲッター（getter）、セッター（setter）と呼ばれます。セッターを記述する時は、受け取る値はnewValueに設定されているのでこれを参照して計算等に使用することができます。記述例を次に示します。</p>

<pre><code>/* モンスタークラス */
class Monster {
    let name: String            // 名前
    var maxHitPoint: Int = 0    // 最大ヒットポイント
    var hitPoint: Int = 0       // ヒットポイント
    // レベル
    var level: Int {
        // 最大ヒットポイントはレベルに依存（下の計算は適当）
        get {   // ゲッター
            return max(1, Int(sqrt(Float(maxHitPoint - 10))))
        }
        set {   // セッター
            maxHitPoint = 10 + newValue * newValue
        }
    }
    // イニシャライザ
    init(name: String, level: Int = 1) {
        self.name = name
        self.level = level
        self.hitPoint = self.maxHitPoint
    }
    // 説明
    func description() -&gt; String {
        return &quot;\(name) Lv.\(level) HP(\(hitPoint)/\(maxHitPoint))&quot;
    }
}

let goblin = Monster(name: &quot;ゴブリン&quot;, level: 10)
print(goblin.description())   // ゴブリン Lv.10 HP(110/110)
goblin.level = 20
print(goblin.description())   // ゴブリン Lv.20 HP(110/410)
</code></pre>

<p>newValueの代わりに、setの後に()で括って名前を渡して使うこともできます。</p>

<pre><code>:
    // レベル
    var level: Int {
        get {
            return max(1, Int(sqrt(Float(maxHitPoint - 10))))
        }
        set(lv) {
            maxHitPoint = 10 + lv * lv
        }
    }
:
</code></pre>

<h3 id="同一インスタンスの判定">同一インスタンスの判定</h3>

<p>２つの変数が同じインスタンスを指しているかどうかは、=== 演算子を使って判定できます。ノットイコールを意味する!==もあります。</p>

<blockquote>
<p>2つの変数が同じインスタンスを指しているかどうかは、==では判定できません。==は変数が指すインスタンス同士の内容が同じかどうかの判定に使用しますが、その実装内容はクラスの設計者に依存します。</p>
</blockquote>

<pre><code>var monsterA = Monster()
monsterA.name = &quot;スライム&quot;
var monsterB = monsterA

if monsterA === monsterB {
    println(&quot;同じインスタンス&quot;)
}
if monsterA !== monsterB {
    println(&quot;同じインスタンスではない&quot;)
}
</code></pre>

<h2 id="構造体">構造体</h2>

<p>カプセル化を実現する方法としてSwiftには、クラスの他に構造体（struct）が用意されています。但し、クラスと構造体には次のような違いがあります。</p>

<ul>
<li>構造体では継承は利用できません。</li>
<li>構造体にデイニシャライザは定義できません。</li>
<li>クラスのインスタンスを別の変数に代入すると参照が渡されます。インスタンスの参照数は参照カウントで管理されます。対して構造体を別の変数に代入すると新たなコピーが生成されます。構造体の参照先は常に１つなので参照カウントは使用されません。</li>
</ul>

<p>構造体の書き方はクラスとよく似ています。</p>

<pre><code>/* 著者 */
struct Author {
    var name: String = &quot;不明&quot;
    var birthday: NSDate?   // NSDateはCocoaフレームワークの日付型
}

let author = Author()
</code></pre>

<p>イニシャライザを使ってメンバ変数を初期化することもできます。</p>

<pre><code>/* 著者 */
struct Author {
    var name: String
    var birthday: NSDate?
    init() {
        name = &quot;不明&quot;
    }
}

let author = Author()
</code></pre>

<p>また、構造体はメンバ変数を引数にもつイニシャライザが自動的に生成されるため、イニシャライザを自前で用意しなくても次のように初期化することができます。</p>

<pre><code>/* 著者 */
struct Author {
    var name: String
    var birthday: NSDate?
}

let formatter = NSDateFormatter()
formatter.dateFormat = &quot;Y/M/d&quot;
let author = Author(name: &quot;夏目漱石&quot;, birthday: formatter.dateFromString(&quot;1867/2/9&quot;))
</code></pre>

<p>プロパティへのアクセスはクラスの場合と同様、.（ドット）を使います。</p>

<pre><code>var author = Author(name: &quot;夏目漱石&quot;, birthday: formatter.dateFromString(&quot;1867/2/9&quot;))
print(&quot;著者:&quot; + author.name)   // 著者:夏目漱石

author.name = &quot;森鴎外&quot;
author.birthday = formatter.dateFromString(&quot;1862/2/17&quot;)
print(&quot;著者:&quot; + author.name)   // 著者:森鴎外
</code></pre>

<p>構造体のメンバに構造体が含まれる場合は次の様に.（ドット）で繋いでアクセスします。</p>

<pre><code>/* 著者 */
struct Author {
    var name: String = &quot;不明&quot;
    var birthday: NSDate?
}

/* 書籍 */
struct Book {
    var title: String
    var author: Author
}

let formatter = NSDateFormatter()
formatter.dateFormat = &quot;Y/M/d&quot;

let book = Book(
    title: &quot;吾輩は猫である&quot;,
    author: Author(name: &quot;夏目漱石&quot;, birthday: formatter.dateFromString(&quot;1867/2/9&quot;))
)

print(&quot;書籍名:\(book.title), 著者:\(book.author.name)&quot;)    // 書籍名:吾輩は猫である, 著者:夏目漱石
</code></pre>

<p>定数として宣言した構造体のプロパティを変更することはできません。</p>

<pre><code>let author = Author(name: &quot;夏目漱石&quot;, birthday: formatter.dateFromString(&quot;1867/2/9&quot;))
author.name = &quot;森鴎外&quot; // エラー（変更できない）
</code></pre>

<p>構造体は変数へ代入される時にプロパティも含めてコピーされます。別の変数に代入した構造体のプロパティを変更しても、元の構造体のプロパティの値は変わりません。
参照が代入され同じインスタンスを複数の変数で共有するクラスの場合とは動作が異なります。</p>

<pre><code>let author = Author(name: &quot;夏目漱石&quot;, birthday: formatter.dateFromString(&quot;1867/2/9&quot;))
var book1 = Book(title: &quot;坊ちゃん&quot;, author: author)
var book2 = book1
book2.title = &quot;吾輩は猫である&quot;

print(book1.title)    // 坊ちゃん
print(book2.title)    // 我が輩は猫である
</code></pre>

<blockquote>
<p>SwiftのString、Array、Dictionaryは、構造体を使って実装されています。つまり、これらを他の変数に代入したり、関数の引数として渡す時には、値がコピーされます。クラスとして実装されているCocoaのNSString、NSArray、NSDictionaryとはこの辺の動作が異なっています。
但し、Swiftのこれらのインスタンスのコピーも、実際に必要になった時点（コピー先のプロパティが実際に変更された時等）でコビーされるようにコンパイラが最適化してくれるので、オーバーヘッドについて過剰に心配する必要はありません。</p>
</blockquote>

<h2 id="プロパティ">プロパティ</h2>

<p>Swiftでは、クラス、構造体、列挙型にプロパティを持たせることができます。プロパティとはこれらの型に関連づけられた属性のことです。</p>

<p>プロパティには、保持型プロパティ（Stored Properties）と計算型プロパティ（Computed Properties）の2種類があります。保持型プロパティは、プロパティ値そのものを値として保持するもので、計算型プロパティは、アクセスされた時に計算した結果を返すものです。</p>

<h3 id="保持型プロパティ">保持型プロパティ</h3>

<p>次の例は、クラスに保持型プロパティを持たせたものです。変数、定数どちらでも持たせることができます。</p>

<pre><code>class Person {
    let name: String    // 名前
    var age: Int        // 年齢

    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
}
</code></pre>

<p>定数のプロパティは、初期値を設定した後は変更することはできません。</p>

<pre><code>var p = Person(name: &quot;山田太郎&quot;, age: 25)
p.age = 30
p.name = &quot;鈴木花子&quot; // エラー
</code></pre>

<p>保持型プロパティの宣言の前にlazyというキーワードをつけると、遅延評価させることができます。
例えば、lazy var hoge: Hoge と宣言すると、hogeというプロパティに実際にアクセスがあるまで、hogeは生成されません。これは、生成にコストがかかるようなインスタンスで、実際にそれが使用されるとは限らないような場合に指定すると、パフォーマンスの向上が期待できます。</p>

<pre><code>class Hoge {
    var text: String
    init() {
        // ファイルを読んだり、ネットワークを調べたりコストのかかる処理
        text = &quot;HogeHoge&quot;
    }
}

class Fuga {
    lazy var hoge = Hoge()
    :
}

let fuga = Fuga()       // この時点ではまだfuga.hogeは生成されない
 :
print(fuga.hoge.text) // ここでfuga.hogeが生成される
</code></pre>

<blockquote>
<p>定数プロパティにlazyを指定することできません。定数はイニシャライザの完了までに値が設定されている必要があるので、lazyを指定する意味がありません。</p>
</blockquote>

<p>Swiftでは関数も型を持ったオブジェクトなのでプロパティとして代入することができます。（このようなオブジェクトを第一級オブジェクトと呼びます。）</p>

<p>次の例では、元号クラスに、現在の元号を返す関数をプロパティとして割り当てています。また、遅延評価させるためにlazyを指定しています。</p>

<pre><code>// 元号情報クラス
class EraInfo {
    // 今の年号を返す
    lazy var currentEra: () -&gt; String = {
        let dateFormatter = NSDateFormatter();
        dateFormatter.dateFormat = &quot;Y/M/d&quot;
        let today = NSDate.date()

        let startDays = [(&quot;1989/1/8&quot;, &quot;平成&quot;), (&quot;1926/12/25&quot;, &quot;昭和&quot;), (&quot;1912/7/30&quot;, &quot;大正&quot;), (&quot;1868/10/23&quot;, &quot;明治&quot;)]
        for day in startDays {
            if today.compare(dateFormatter.dateFromString(day.0)!) == NSComparisonResult.OrderedDescending {
                return day.1
            }
        }
        return &quot;不明&quot;
    }
}

let info = EraInfo()
print(info.currentEra()) // 平成
</code></pre>

<p>プロパティなので後から内容を変えることもできます。</p>

<pre><code>info.currentEra = {
    return &quot;平成&quot;  // 常に平成
}
</code></pre>

<h3 id="計算型プロパティ">計算型プロパティ</h3>

<p>計算型プロパティは、値を保持せずに、他のプロパティの値から都度計算して結果を返したり、設定したりするプロパティです。
値の返却と設定に、get（ゲッター）、set（セッター）を使います。次の例では、ageというプロパティにアクセスすると生年月日から年齢を算出して返してます。また、ageを設定した時に、生年月日と計算が合わない場合は生まれ年を設定し直しています。</p>

<pre><code>class Person {
    var birthday: NSDate    // 生年月日
    var age: Int {          // 年齢
        get {
            let components = self.calendar.components(.CalendarUnitYear, fromDate: birthday, toDate: NSDate.date(), options: .allZeros)
            return components.year
        }
        set(newAge) {
            let diff = self.age - newAge
            if diff != 0 {
                self.birthday = self.calendar.dateByAddingUnit(.CalendarUnitYear, value: diff, toDate: self.birthday, options: .allZeros)
            }
        }
    }
    let dateFormatter: NSDateFormatter  // 日付フォーマッタ
    let calendar: NSCalendar            // カレンダー
    // イニシャライザ
    init(birthday: String) {
        self.dateFormatter = NSDateFormatter();
        self.dateFormatter.dateFormat = &quot;Y/M/d&quot;
        self.calendar = NSCalendar.currentCalendar()
        self.birthday = self.dateFormatter.dateFromString(birthday)!
    }
}

let p = Person(birthday: &quot;1980/12/31&quot;)
print(p.age)
p.age = p.age - 2
print(p.birthday)     // 1982/12/31
</code></pre>

<p>上の例では、セッターにnewAgeという引数名を与えていますが、引数名を与えずに、newValueで、設定値を取得することもできます。</p>

<pre><code>:
        set {
            let diff = self.age - newValue
            if diff != 0 {
                self.birthday = self.calendar.dateByAddingUnit(.CalendarUnitYear, value: diff, toDate: self.birthday, options: .allZeros)
            }
        }
:
</code></pre>

<p>セッターを提供しないことでリードオンリーなプロパティにすることもできます。ゲッターのみの場合は、getも不要です。</p>

<pre><code>class Person {
    var birthday: NSDate    // 生年月日
    var age: Int {          // 年齢
        let components = self.calendar.components(.CalendarUnitYear, fromDate: birthday, toDate: NSDate.date(), options: .allZeros)
        return components.year
    }
    let dateFormatter: NSDateFormatter  // 日付フォーマッタ
    let calendar: NSCalendar            // カレンダー
    // イニシャライザ
    init(birthday: String) {
        self.dateFormatter = NSDateFormatter();
        self.dateFormatter.dateFormat = &quot;Y/M/d&quot;
        self.calendar = NSCalendar.currentCalendar()
        self.birthday = self.dateFormatter.dateFromString(birthday)!
    }
}
</code></pre>

<h3 id="プロパティ監視">プロパティ監視</h3>

<p>プロパティ値が設定される前と設定された後に処理を行うことができます。この機能をプロパティ監視と呼びます。</p>

<p>値が変更される前に、willSet()が呼ばれます。また、値が変更された後に、didSet()が呼ばれます。</p>

<pre><code>/* パーソンクラス */
class Person {
    let name: String
    var age: Int = 0 {
        willSet {
            print(&quot;\(self.age)歳から\(newValue)歳へ年齢を変更します。&quot;)
        }
        didSet {
            print(&quot;\(oldValue)歳から\(self.age)歳へ年齢を変更しました。&quot;)
        }
    }
    // イニシャライザ
    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
}

let p = Person(name: &quot;山田太郎&quot;, age: 30)
p.age = 31
/*
30歳から31歳へ年齢を変更します。
30歳から31歳へ年齢を変更しました。
*/
</code></pre>

<p>プロパティ監視は、イニシャライザ内からの変更時には呼び出されません。上の例では、init()の中で、self.age としていますが、ここではwillSet()もdidSet()も呼び出されていません。インスタンスの生成が終わって、p.age = 31 としている所で初めて呼び出されています。</p>

<blockquote>
<p>didSetの中でそのプロパティに別の値を設定すると上書きされます。willSet()やdidSet()が再度呼ばれることはありません。</p>
</blockquote>

<p>上の例のように、willSetに引数を与えない場合は、newValueで新しい値を参照できます。同様にdidSetに引数を与えない場合は、oldValueで、変更前の値を参照できます。
セッターやゲッターの場合と同様、次の様に引数を与えてその名前を使って参照することもできます。</p>

<pre><code>var age: Int = 0 {
    willSet(newAge) {
        print(&quot;\(self.age)歳から\(newAge)歳へ年齢を変更します。&quot;)
    }
    didSet(oldAge) {
        print(&quot;\(oldAge)歳から\(self.age)歳へ年齢を変更しました。&quot;)
    }
}
</code></pre>

<p>CocoaやUIKitを使ったアプリケーションの開発では、デリゲートパターンを多用します。デリゲートパターンは、イベントに応じて他のオブジェクトにイベントを通知したり処理を委譲するパターンですが、プロパティ監視を使うと、値の変更に応じたイベントの通知を簡単に実装することができます。</p>

<pre><code>/* バーソンプロトコル */
protocol PersonDelegate {
    func person(person: Person, willChangeAge age:Int)
    func person(person: Person, didChangeAge age:Int)
}

/* パーソンクラス */
class Person {
    var delegate: PersonDelegate?
    let name: String
    var age: Int = 0 {
        willSet(newAge) {
            delegate?.person(self, willChangeAge: newAge)
        }
        didSet(oldAge) {
            delegate?.person(self, didChangeAge: oldAge)
        }
    }
    // イニシャライザ
    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
}

let p = Person(name: &quot;山田太郎&quot;, age: 30)
p.delegate = someDelegate;
p.age = 31
</code></pre>

<blockquote>
<p>プロパティ監視は、遅延評価型のプロパティでは使用できません。また、計算型プロパティにも使用できません。計算型プロパティではセッターに直接処理を書けるからです。但し、計算型プロパティをもつクラスを継承したサブクラスでは、親クラスの計算型プロパティの監視は可能です。</p>

<p>配列やディクショナリ型のプロパティに対するプロパティ監視は、配列やディクショナリ全体の代入のみでなく、要素を追加したり削除する場合も呼ばれます。</p>
</blockquote>

<pre><code>class Person {
    let name: String
    var friends: [Person]? {
        willSet {
            for p in newValue! {
                print(p.name)
            }
        }
    }
    init(_ name: String) {
        self.name = name
    }
}

let p = Person(&quot;ルフィ&quot;)
p.friends = [Person(&quot;ゾロ&quot;), Person(&quot;ナミ&quot;), Person(&quot;ウソップ&quot;)]
/* 実行結果
   ゾロ
   ナミ
   ウソップ
*/
p.friends!.append(Person(&quot;サンジ&quot;))
/* 実行結果
   ゾロ
   ナミ
   ウソップ
   サンジ
*/
p.friends!.removeAtIndex(2)
/* 実行結果
   ゾロ
   ナミ
   サンジ
*/
</code></pre>

<h3 id="型プロパティ">型プロパティ</h3>

<p>クラスや構造体のインスタンスではなく、クラスや構造体、列挙型そのものにプロパティを持たせることができます。他の言語ではクラスのこのようなプロパティをクラス変数と呼んだり、静的メンバ変数と呼んだりします。
構造体と列挙型については、保持型プロパティと計算型プロパティのどちらでも持たせることができます。クラスについては、計算型プロパティのみ持たせられます。また、クラスや構造体自体のイニシャライザが無いため、保持型プロパティは宣言時に初期値を与える必要があります。</p>

<p>構造体の型プロパティは、次のようにstaticをつけて宣言します。</p>

<pre><code>/* ログイン情報 */
struct LoginInfo {
    static var url = &quot;https://login.example.com/&quot;
    static var port: Int {
        if self.url.hasPrefix(&quot;https&quot;) {
            return 443
        } else {
            return 80
        }
    }

    var userid: String
    var password: String
}

print(LoginInfo.url)      // https://login.example.com/
print(LoginInfo.port)     // 443
</code></pre>

<p>列挙型の型プロパティも同様です。</p>

<pre><code>/* 曜日 */
enum DayOfWeek: Int {
    static var firstDay: DayOfWeek {
        return .Sunday
    }
    static var lastDay: DayOfWeek {
        return .Saturday
    }

    case Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday
}

print(DayOfWeek.firstDay.toRaw()) // 0
print(DayOfWeek.lastDay.toRaw())  // 6
</code></pre>

<p>クラスの型プロパティは上の２つと異なり、classをつけて宣言します。</p>

<pre><code>/* パーソンクラス */
class Person {
    class var tableName: String {
        return &quot;people&quot;     // データペーステーブル名
    }

    var name: String
    var address: String
    var tel: String
    var email: String
    init(name: String, address: String, tel: String, email: String) {
        self.name = name
        self.address = address
        self.tel = tel
        self.email = email
    }
}

print(Person.tableName)   // people
</code></pre>

<blockquote>
<p>Swift1.2から、クラスのクラス変数もstaticで宣言できるようになりました。</p>
</blockquote>

<pre><code>/* パーソンクラス */
class Person {
    static var tableName = &quot;people&quot;    // データペーステーブル名

    var name: String
    var address: String
    var tel: String
    var email: String
    init(name: String, address: String, tel: String, email: String) {
        self.name = name
        self.address = address
        self.tel = tel
        self.email = email
    }
}

print(Person.tableName)   // people
</code></pre>

<p>型フロパティはインスタンスの属性としてアクセスすることはできません。あくまでも型名.プロパティ名という形式でアクセスします。</p>

<pre><code>/* ログイン情報 */
struct LoginInfo {
    static var url = &quot;https://login.example.com/&quot;
    :
}

print(LoginInfo.url)

var l = LoginInfo(userid: &quot;hogehoge&quot;, password: &quot;abcd123&quot;)
print(l.url)   // エラー
</code></pre>

<h2 id="メソッド">メソッド</h2>

<p>Swiftでは、クラスだけでなく、構造体や列挙型にもメソッド（関数）を持たせることができます。また、Objective-Cのクラスメソッドにあたる型メソッドも、クラス、構造体、列挙型に持たせることができます。</p>

<h3 id="インスタンスメソッド">インスタンスメソッド</h3>

<p>メソッドの定義は基本的には関数の定義と同じです。型の定義の中に、funcをつけて記述します。</p>

<pre><code>/* 職種 */
enum Job {
    case Warrior, Mage, Thief, Priest
    func initialHitPoint() -&gt; Int {
        switch self {
        case .Warrior:  // 戦士
            return 100
        case .Mage:     // 魔法使い
            return 40
        case .Thief:    // 盗賊
            return 60
        case .Priest:   // 僧侶
            return 30
        }
    }
}

/* キャラクタ */
class GameCharacter {
    var name: String
    var job: Job
    var maxHitPoint: Int {
        didSet {
            self.hitPoint = self.maxHitPoint
        }
    }
    var hitPoint: Int = 0
    // イニシャライザ
    init(name: String, job: Job) {
        self.name = name
        self.job = job
        self.maxHitPoint = self.job.initialHitPoint()
    }
    // ダメージを与える
    func addDamage(damage: Int) {
        hitPoint -= damage
        if hitPoint &lt;= 0 {
            print(&quot;死んだ&quot;)
        }
    }

}
</code></pre>

<p>インスタンスメソッドを呼び出す場合は、フロパティと同様、.（ドット）をつけて呼び出します。</p>

<pre><code>let player = GameCharacter(name: &quot;ヨシヒコ&quot;, job: .Warrior)
print(player.hitPoint)   // 100
player.addDamage(40)
print(player.hitPoint)   // 60
</code></pre>

<h3 id="引数名">引数名</h3>

<p>メソッドの引数名も関数の場合と同様、外部名と内部名を指定できます。但し、メソッドの場合は、2つ目の引数以降は特に明示的に指定しない限りデフォルトで内部名が外部名扱いになります。
上の例で、addDamageメソッドに第2引数をつけて次の様にしたとすると、呼び出し時に第2引数のラベルが必要になります。</p>

<pre><code>    :
    // ダメージを与える
    func addDamage(damage: Int, times: Int) {
        hitPoint -= damage * times
        if hitPoint &lt; 0 {
            print(&quot;死んだ&quot;)
        }
    }
}
let player = GameCharacter(name: &quot;ヨシヒコ&quot;, job: .Warrior)
player.addDamage(40, times: 3)
// 死んだ
</code></pre>

<p>第1引数にも外部名をつけたい場合は、関数の場合と同様、明示的に書くか、内部名の前に#をつけます。</p>

<pre><code>    :
    // ダメージを与える
    func addDamage(#damage: Int, times: Int) {
        hitPoint -= damage * times
        if hitPoint &lt; 0 {
            print(&quot;死んだ&quot;)
        }
    }
}
:
player.addDamage(damage: 40, times: 3)
</code></pre>

<p>第2引数以降のラベルを省略したい場合（推奨されませんが）は、外部名として、_（下線）を指定します。これも関数の場合と同様です。</p>

<pre><code>    :
    // ダメージを与える
    func addDamage(damage: Int, _ times: Int) {
        hitPoint -= damage * times
        if hitPoint &lt; 0 {
            print(&quot;死んだ&quot;)
        }
    }
}
:
player.addDamage(40, 3)
</code></pre>

<blockquote>
<p>Swiftのメソッドの第2引数以降のラベルがデフォルトで必要になっているのはObjective-Cの関数の書き方とよく似ています。例えば、UIKitのテーブルビューのセルを返すメソッドがUITalbeViewDataSourceプロトコルにありますが、このメソッドは、Objective-Cでは次の様に定義されています。</p>
</blockquote>

<pre><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;

// メソッドの呼び出し
UITableViewCell *cell = [dataSource tableView:tableView cellForRowAtIndexPath:indexPath];
</code></pre>

<p>このメソッドのSwift版は、次のようになります。</p>

<pre><code>func tableView(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!) -&gt; UITableViewCell!

// メソッドの呼び出し
let cell = dataSource.tableView(tableView, cellForRowAtIndexPath: indexPath)
</code></pre>

<p>このように、メソッド呼び出しの書き方がObjective-CとSwiftで似たようなスタイルになるので、Objective-Cからの移行がしやすくなっています。また、このスタイルに合わせるためには、関数名の最後が第一引数の意味と合うように命名する必要があります。</p>

<pre><code>// 例
func replaceAtIndex:(index: Int, withData: MyData)
func hitBy:(monster: Monster, atLocationX: Int, andY: Int)
</code></pre>

<h3 id="破壊的メソッド">破壊的メソッド</h3>

<p>構造体、列挙型のメソッドは、デフォルトでは属性の変更はできません。クラスの場合は可能です。</p>

<pre><code>/* 職種 */
enum Job {
    case Warrior, Mage, Thief, Priest
}

/* ゲームキャラクタ */
struct GameCharacter {
    var name: String        // 名前
    var job: Job            // 職種
    var level: Int          // レベル
    func changeJob(newJob: Job) {
        self.job = newJob   // コンバイルエラー
    }
}
</code></pre>

<p>構造体や列挙型のメソッドで値を変更するには、funcの前に、mutatingをつけて宣言する必要があります。</p>

<pre><code>/* ゲームキャラクタ */
struct GameCharacter {
    var name: String        // 名前
    var job: Job            // 職種
    var level: Int          // レベル
    mutating func changeJob(newJob: Job) {
        self.job = newJob   //  OK
    }
}
</code></pre>

<p>また、定数の構造体や列挙型の破壊的メソッドを呼び出す事はできません。変数であれば可能です。</p>

<pre><code>let player1 = GameCharacter(name: &quot;ヨシヒコ&quot;, job: .Warrior, level: 10)
player.changeJob(.Mage)     // コンパイルエラー

var player2 = GameCharacter(name: &quot;ダンジョー&quot;, job: .Warrior, level: 10)
player2.changeJob(.Mage)     // OK
</code></pre>

<p>破壊的メソッドでは、次のようにself自体を変更することも可能です。</p>

<pre><code>/* ゲームキャラクタ */
struct GameCharacter {
    :
    mutating func changeJob(newJob: Job) {
        self = GameCharacter(name: self.name, job: newJob, level: self.level)
    }
}

var player = GameCharacter(name: &quot;ヨシヒコ&quot;, job: .Warrior, level: 10)
player.changeJob(.Mage)

print(player.job == .Mage)    // true
</code></pre>

<pre><code>/* オセロの駒 */
enum OthelloPiece {
    case White, Black
    mutating func reverse() {
        self = (self == .White ? .Black : .White)
    }
}

var piece = OthelloPiece.White
piece.reverse();
print(piece == .Black)    // true
</code></pre>

<blockquote>
<p>クラスのメソッドにmutatingは不要です。（つけるとエラーになる。）クラスの場合は最初からメソッド内でプロパティの変更が可能です。これは型が値型（変数や定数に値全体のコピーが代入される。IntやString等のプリミティブな型も値型）か、参照型（変数や定数に、インスタンスのアドレスが代入される）かの違いによるものです。構造体と列挙型は値型で、クラスは参照型です。</p>
</blockquote>

<h3 id="型メソッド">型メソッド</h3>

<p>型メソッドは、クラスや構造体のインスタンスではなく、型自体に属するメソッドです。他の言語ではクラスメソッドや静的メンバ関数と呼んだりします。
型プロパティと同様、構造体と列挙型の場合はstatic、クラスの場合は、class をつけて定義します。呼び出す時は、 <strong>型名.メソッド名</strong> の形で呼び出します。</p>

<pre><code>/* じゃんけん */
enum Janken {
    case goo, choki, paa
    static func sayPriming() {
        print(&quot;最初はグー&quot;)
    }
}
Janken.sayPriming()     // 最初はグー
</code></pre>

<p>型メソッド内で、型プロパティに直接アクセスできます。プロパティの前に型名をつける必要はありません。</p>

<pre><code>/* ログイン情報 */
struct LoginInfo {
    static var url = &quot;https://login.example.com/&quot;
    static func isSecure() -&gt; Bool {
        return url.hasPrefix(&quot;https:&quot;)
    }

    var userid: String
    var password: String
}

print(LoginInfo.isSecure())   // true
</code></pre>

<pre><code>/* パーソンクラス */
class Person {
    class var tableName: String {
        return &quot;people&quot;     // データペーステーブル名
    }
    class func tableNameWithPrefix(prefix: String) -&gt; String {
        return &quot;\(prefix)_\(tableName)&quot;
    }

    var name: String
    var address: String
    var tel: String
    var email: String
    init(name: String, address: String, tel: String, email: String) {
        self.name = name
        self.address = address
        self.tel = tel
        self.email = email
    }
}

print(Person.tableNameWithPrefix(&quot;bak&quot;))  // bak_people
</code></pre>

<h2 id="サブスクリプト">サブスクリプト</h2>

<p>サブスクリプトとは、配列やディクショナリの要素にアクセスする時等に使う添字式のことです。Swiftでは、構造体、列挙型、クラスにサブスクリプトによるアクセスを実装することができます。</p>

<p>サブスクリプトによるアクセスを実装するには、次のような内容をクラス等の定義に記述します。</p>

<pre><code>class Hoge {
    :
    subscript(index: Int) -&gt; Int {
        get {
            // 添字:indexの位置を値を返す
        }
        set(newValue) {
            // newValueを受け取る
        }
    }
}
</code></pre>

<p>プロパティの場合と同じように、ゲッター、セッターを記述して、受け取ったindex位置の値を返したり、新たな値を受け取ることができます。
セッターは、特に指定しなければ、newValueで受け取る値を参照できます。上の例のように、引数名を明示的に指定することも可能です。</p>

<p>このクラスのインスタンスに対して、次のようなアクセスが可能になります。</p>

<pre><code>let hoge = Hoge()
hoge[2] = 10
print(hoge[2])
</code></pre>

<p>読み出しのみでセッターが不要な場合は、ゲッターのみを記述します。プロパティの場合と同様、get自体の記述も不要になります。</p>

<pre><code>class Hoge {
    :
    subscript(index: Int) -&gt; Int {
        return 〜
    }
}
</code></pre>

<p>また、1つのクラスに引数や戻り値の型の異なる複数のサブスクリプトを定義することもできます。呼び出されるサブスクリプトは型によって類推されます。</p>

<pre><code>class Doubler {
    // 受け取った添字の値を2倍して返す。
    subscript(index: Int) -&gt; Int {
        return index * 2
    }
    // 引数がString
    subscript(index: String) -&gt; Int {
        return index.toInt()! * 2
    }
    // 戻り値がString
    subscript(index: Int) -&gt; String {
        return &quot;[\(index * 2)]&quot;
    }
}

let doubler = Doubler()
let i1: Int = doubler[3]        // 6
let i2: Int = doubler[&quot;3&quot;]      // 6
let s: String = doubler[3]      // &quot;[6]&quot;
</code></pre>

<p>複数の添字を使ったサブスクリプトも定義できます。</p>

<pre><code>class Multiplier {
    // 2つの引数の乗算結果を返す
    subscript(val1: Int, val2: Int) -&gt; Int {
        return val1 * val2
    }
}

let m = Multiplier()
print(m[2, 3])     // 6
</code></pre>

<p>次は、サブスクリプトを使ってオセロ盤の各マス目にアクセスできるようにした例です。</p>

<pre><code>/* オセロのコマ */
enum Piece {
    case Black, White
}

/* オセロ盤 */
class OthelloBoard {
    class var rows: Int    { return 8 }
    class var columns: Int { return 8 }
    class var squares: Int { return rows * columns }
    var board: [Piece?]
    init() {
        board = Array(count: OthelloBoard.squares, repeatedValue: nil)
        self[3, 3] = .Black;  self[3, 4] = .White
        self[4, 3] = .White; self[4, 4] = .Black
    }
    // 指定されたマス目のコマを返す
    subscript(row: Int, column: Int) -&gt; Piece? {
        get {
            checkSquare(row, column: column)
            return board[row * OthelloBoard.columns + column]
        }
        set {
            checkSquare(row, column: column)
            board[row * OthelloBoard.columns + column] = newValue
        }
    }
    // 位置の検証
    func checkSquare(row: Int, column: Int) {
        assert(row &lt; OthelloBoard.rows &amp;&amp; column &lt; OthelloBoard.columns, &quot;不正な位置&quot;)
    }
}

let board = OthelloBoard()
board[3, 5] = .Black
</code></pre>

<h2 id="継承">継承</h2>

<p>継承とは親クラスの属性を引き継いで新たなクラスを作成することです。継承するクラスをサブクラス又は子クラス、継承されるクラスをスーバークラス又は親クラスと呼びます。
また、継承ツリーの起点となるクラスのことをベースクラスと呼びます。</p>

<blockquote>
<p>Objective-Cでは、全てのクラスは、NSObject又は、NSObjectをベースクラスとするクラスを継承する必要がありますが、Swiftでは、ユーザ定義のクラスをベースクラスとすることができます。特定のクラスを継承する必要はありません。</p>
</blockquote>

<h3 id="サブクラス">サブクラス</h3>

<p>別のクラスを継承したサブクラスを作成するには、クラスを定義する時にクラス名の後に:（コロン）をつけて、スーバークラス名を指定します。</p>

<pre><code>/* モンスタークラス */
class Monster {
    var name: String	// 名前
    var level: Int	    // レベル
    // イニシャライザ
    init(name: String, level: Int = 1) {
        self.name = name
        self.level = level
    }
    // ステータス表示
    func printStatus() {
        print(&quot;名前:\(name) レベル:\(level)&quot;)
    }
    // 攻撃
    func attackMonster(enemy: Monster) {
        print(&quot;\(name)は\(enemy.name)を攻撃した。&quot;);
    }
}

/* スライムクラス */
class Slime: Monster {
    // イニシャライザ
    init(level: Int = 1) {
        super.init(name: &quot;スライム&quot;, level: level)
    }
}

/* ドラゴンクラス */
class Dragon: Monster {
    // イニシャライザ
    init(level: Int = 1) {
        super.init(name: &quot;ドラゴン&quot;, level: level)
    }
}

let monster = Monster(name: &quot;踊るガイコツ&quot;, level:3)
let slime = Slime()
let dragon = Dragon(level: 10)
monster.printStatus()   // 名前:踊るガイコツ レベル:3
slime.printStatus()     // 名前:スライム レベル:1
dragon.printStatus()    // 名前:ドラゴン レベル:10
</code></pre>

<p><strong>super</strong> で、スーパークラスのメソッドやプロパティにアクセスできます。上の例ではイニシャライザでスーバークラスのイニシャライザを呼び出しています。スーバークラスのサブスクリプトにアクセスする場合は、super[index]の形でアクセスできます。</p>

<p>サブクラスをさらに継承してクラスを作ることもできます。</p>

<pre><code>/* メタルスライムクラス */
class MetalSilme: Slime {
    // イニシャライザ
    override init(level: Int = 1) {
        super.init(level: level)
        self.name = &quot;メタルスライム&quot;
    }
}
</code></pre>

<p>上のクラスで、イニシャライザの記述の前に <strong>override</strong> が指定されています。イニシャライザに限らず、スーバークラスで既に定義されているメソッドと同じシグニチャ（同じ名前、同じ引数、同じ戻り値）のメソッドを定義する場合は、 <strong>override</strong> を指定する必要があります。これは誤ってスーバークラスのメソッドを上書きしてしまうミスを防ぐためです。overrideを指定したメソッドと同じメソッドがスーバークラス（継承ツリーのどこか）に定義されていない場合もエラーになります。</p>

<blockquote>
<p>Swiftでは、直接指定できる親クラスは1つだけです。C++言語等にある多重継承はできません。複数の特徴を併せ持つことを表現する場合は、プロトコル（Javaのインターフェースに相当）を使用します。</p>
</blockquote>

<p>サブクラスに、新たなプロパティを追加することもできます。</p>

<pre><code>/* メタルスライムクラス */
class MetalSilme: Slime {
    var isStrayed: Bool   // はぐれ?
    // イニシャライザ
    init(isStrayed: Bool, level: Int = 1) {
        self.isStrayed = isStrayed
        super.init(level: level)
        if self.isStrayed {
            self.name = &quot;メタルスライム&quot;
        } else {
            self.name = &quot;はぐれメタル&quot;
        }
    }
}
</code></pre>

<p>上の例では、isStrayというBool型のプロパティを追加しています。イニシャライザの引数も合わせて変更したことでシグニチャが変わったので、overrideの指定は不要になりました。</p>

<p>サブクラスのイニシャライザでは、このようにサブクラスの自身のプロパティの初期化をまず行い、次にスーパークラスのイニシャライザを呼び、その後に追加の設定を行うという流れになります。プロバティの初期化を行わずに、スーバークラスのイニシャライザを呼び出すとコンパイルエラーになります。
プロパティの宣言と同時にvar isStrayed = false 等と初期化をする場合はイニシャライザの中での初期化は不要です。</p>

<h3 id="ポリモーフィズム">ポリモーフィズム</h3>

<p>サブクラスでスーバークラスのメソッドをオーバーライドした場合、そのクラスのインスタンスをスーバークラスの型の変数に代入してスーバークラスのメソッドを呼び出しても、サブクラスのメソッドが呼び出されます。この性質をポリモーフィズム、又は日本語で多態性と呼びます。
次の例では、Monster型の変数に、Monsterクラスを継承したサブクラスのインスタンスを生成し、MonsterクラスのattackMonsterメソッドを呼び出していますが、実際に呼び出されるメソッドはサブクラスのメソッドです。（サブクラスでメソッドがオーバーライドされていなければ、スーバークラスのメソッドが呼び出されます。）</p>

<pre><code>/* モンスタークラス */
class Monster {
    var name: String	// 名前
    var level: Int	// レベル
    // イニシャライザ
    init(name: String, level: Int = 1) {
        self.name = name
        self.level = level
    }
    // 攻撃
    func attackMonster(enemy: Monster) {
        println(&quot;\(name)は\(enemy.name)を攻撃した。&quot;);
    }
}

/* スライムクラス */
class Slime: Monster {
    // イニシャライザ
    init(level: Int = 1) {
        super.init(name: &quot;スライム&quot;, level: level)
    }
}

/* ドラゴンクラス */
class Dragon: Monster {
    // イニシャライザ
    init(level: Int = 1) {
        super.init(name: &quot;ドラゴン&quot;, level: level)
    }
    // 攻撃
    override func attackMonster(enemy: Monster) {
        println(&quot;\(name)は\(enemy.name)に火を吐いた。&quot;);
    }
}

var skeleton, slime, dragon: Monster
skeleton = Monster(name: &quot;踊るガイコツ&quot;)
slime = Slime()
dragon = Dragon()

skeleton.attackMonster(slime)   // 踊るガイコツはスライムを攻撃した。  &lt;== Monsterクラスのメソッドが呼ばれた
slime.attackMonster(skeleton)   // スライムは踊るガイコツを攻撃した。  &lt;== Slimeクラスのメソッドが呼ばれた
dragon.attackMonster(slime)     // ドラゴンはスライムに火を吐いた。   &lt;== Dragonクラスのメソッドが呼ばれた
</code></pre>

<blockquote>
<p>オーバーライドとよく似た言葉にオーバーロードがあります。これもオブジェクト指向でよく見かける言葉ですが、オーバーライドが、スーパークラスの同じシグニチャ（名前、引数、戻り値が同じ）のメソッドをそのまま上書きするのに対して、オーバーロードは、メソッド名は同じでも、引数や戻り値の異なるメソッドを定義することを意味します。つまりメソッドの上書きではなく別バージョンを作ることを意味します。（言語によっては引数の型や数の変更のみで、戻り値の変更は出来ないものもあります。）
例えば次のように、引数の異なるattackMonsterメソッドを追加すると、attackMonsterメソッドのオーバーロードになります。（オーバーロードに、overloadのような指定はありません。）</p>
</blockquote>

<pre><code>/* モンスタークラス */
class Monster {
    :
    // 攻撃
    func attackMonster(enemy: Monster) {
        println(&quot;\(name)は\(enemy.name)を攻撃した。&quot;);
    }
    // オーバーロード（引数の数が違う）
    func attackMonster(enemy: Monster, times: Int) {
        println(&quot;\(name)は\(enemy.name)を\(times)回攻撃した。&quot;);
    }
}

/* スライムクラス */
class Slime: Monster {
    :
    // オーバーライド（スーバークラスのメソッドと同じシグニチャ）
    override func attackMonster(enemy: Monster, times: Int) {
        println(&quot;\(name)は\(enemy.name)に\(times)回ぶつかった。&quot;);
    }
    // オーバーロード（引数の型が違う）
    func attackMonster(enemy: Dragon) {
        println(&quot;\(name)は逃げ出した。&quot;);
    }
}

var skeleton = Monster(name: &quot;踊るガイコツ&quot;)
var dragon = Dragon()
var slime = Slime()
skeleton.attackMonster(slime, times:3)  // 踊るガイコツはスライムを3回攻撃した。
slime.attackMonster(dragon)             // スライムは逃げ出した。
</code></pre>

<p>※上の例では、SlimeクラスのattackMonsterメソッドの引数にDragonクラス型の変数に代入したインスタンスを渡しています。Monsterクラス型の変数にDragonのクラスインスタンスを代入したものを渡しても、スーパークラスのメソッドの方が呼ばれてしまいます。</p>

<pre><code>var slime, dragon: Monster
slime = Slime()
dragon = Dragon()
slime.attackMonster(dragon)             // スライムはドラゴンを攻撃した。
</code></pre>

<p>このようにインスタンスそのものではなく、引数自体の型で判断されます。
型キャストを使って、</p>

<pre><code>slime.attackMonster(dragon as Dragon)    // スライムは逃げ出した。
</code></pre>

<p>と明示的に呼び出す方法もありますが、型の違いを意識せずに引数を渡したい場合は、オーバーロードではなく、Slimeクラスのメソッドを次の様にオーバーライドする方法もあります。</p>

<pre><code>// 攻撃
override func attackMonster(enemy: Monster) {
    if enemy is Dragon {
        println(&quot;\(name)は逃げ出した。&quot;);
    } else {
        super.attackMonster(enemy)
    }
}
</code></pre>

<p><strong>is</strong> は、変数が、指定した型、又は指定した型のサブクラスかどうかを判定してBool型を返す演算子です。</p>

<h3 id="オーバーライド">オーバーライド</h3>

<p>インスタンスメソッドのオーバーライドは上の例でも出てきましたが、他にプロパティやサブスクリプト、クラスメソッド等のオーバーライドも可能です。例を次に示します。</p>

<pre><code>/* モンスタークラス */
class Monster {
    // 名前
    var name: String
    // レベル
    var level: Int {
        didSet {
            maxHitPoint = level * 5
        }
    }
    // ヒットポイント
    var hitPoint: Int = 0 {
        didSet {
            if hitPoint &lt;= 0 {
                println(&quot;\(name)は死んだ&quot;)
            }
        }
    }
    // 最大ヒットポイント
    var maxHitPoint: Int {
        get {
            return level * 5
        }
        set {
            level = newValue / 5
        }
    }
    // 死んだ？
    var isDead: Bool {
        return hitPoint &lt;= 0
    }
    // イニシャライザ
    init(name: String, level: Int = 1) {
        self.name = name
        self.level = level
        self.hitPoint = self.maxHitPoint
    }
    // ダメージ計算
    func calculateDamage(enemy: Monster) -&gt; Int {
        // 計算は適当
        return max(0, (level * 5 - enemy.level) + (Int(rand()) % level))
    }
    // 攻撃
    func attackMonster(enemy: Monster) {
        var damage = self.calculateDamage(enemy)
        println(&quot;\(name)は\(enemy.name)に\(damage)ポイントのダメージを与えた。&quot;)
        enemy.hitPoint -= damage
    }
}

/* ドラゴンクラス　*/
class Dragon: Monster {
    override var level: Int {
        didSet {
            maxHitPoint = level * 100
        }
    }
    override var maxHitPoint: Int {
        get {
            return level * 100
        }
        set {
            level = newValue / 100
        }
    }
    // イニシャライザ
    init(level: Int = 1) {
        super.init(name: &quot;ドラゴン&quot;, level: level)
    }
    // ダメージ計算
    override func calculateDamage(enemy: Monster) -&gt; Int {
        // 計算は適当
        return max(0, (level * 100 - enemy.level) + (Int(rand()) % level))
    }
}

var slime, dragon: Monster
slime = Monster(name: &quot;スライム&quot;)
dragon = Dragon()
slime.attackMonster(dragon)
dragon.attackMonster(slime)

/* 実行結果
スライムはドラゴンに4ポイントのダメージを与えた。
ドラゴンはスライムに99ポイントのダメージを与えた。
スライムは死んだ
*/
</code></pre>

<p>MonsterクラスのhitPointとmaxHitPointをオーバーライドしています。メソッドの場合と同様にoverrideの指定が必要です。</p>

<p>上の例では、5と100というマジックナンバーがソースコードに複数出現しています。リファクタリングしてこの値をクラス変数にしてみます。</p>

<pre><code>/* モンスタークラス */
class Monster {
    // レベル係数
    class var levelFactor: Int {
        return 5
    }
    // 名前
    var name: String
    // レベル
    var level: Int {
        didSet {
            maxHitPoint = level * self.dynamicType.levelFactor
        }
    }
    // ヒットポイント
    var hitPoint: Int = 0 {
        didSet {
            if hitPoint &lt;= 0 {
                println(&quot;\(name)は死んだ&quot;)
            }
        }
    }
    // 最大ヒットポイント
    var maxHitPoint: Int {
        get {
            return level * self.dynamicType.levelFactor
        }
        set {
            level = newValue / self.dynamicType.levelFactor
        }
    }
    :
    // イニシャライザ
    init(name: String, level: Int = 1) {
        self.name = name
        self.level = level
        self.hitPoint = self.maxHitPoint
    }
    // ダメージ計算
    func calculateDamage(enemy: Monster) -&gt; Int {
        // 計算は適当
        return max(0, (level * self.dynamicType.levelFactor - enemy.level) + (Int(rand()) % level))
    }
    :
}

/* ドラゴンクラス　*/
class Dragon: Monster {
    // レベル係数
    override class var levelFactor: Int {
        return 100
    }
    init(level: Int = 1) {
        super.init(name: &quot;ドラゴン&quot;, level: level)
    }
    :
}
</code></pre>

<p>マジックナンバーをレベル係数というクラス変数で返すようにしたので、サブクラスでもクラス変数のオーバーライドだけで済むようになりました。</p>

<p>上で使っている、dynamicTypeは、指定したインスタンスの型を返すメソッドです。インスタンスのクラスからクラス変数を取得するために使っています。</p>

<h3 id="オーバーライドの禁止">オーバーライドの禁止</h3>

<p>サブクラスによるメソッドやプロパティのオーバーライドを禁止することができます。オーバーライドを禁止するには、宣言の頭にfinalを指定します。</p>

<pre><code>/* モンスタークラス */
class Monster {
    :
    // レベル
    final var level: Int {
        didSet {
            maxHitPoint = level * self.dynamicType.levelFactor
        }
    }
    // 最大ヒットポイント
    final var maxHitPoint: Int {
        get {
            return level * self.dynamicType.levelFactor
        }
        set {
            level = newValue / self.dynamicType.levelFactor
        }
    }
    // ダメージ計算
    final func calculateDamage(enemy: Monster) -&gt; Int {
        // 計算は適当
        return max(0, (level * self.dynamicType.levelFactor - enemy.level) + (Int(rand()) % level))
    }
    :
}

/* スライムクラス */
class Slime: Monster {
    // エラー
    override var level: Int {
        :
    }
    // エラー
    override var maxHitPoint: Int {
        :
    }
    // エラー
    override func calculateDamage(enemy: Monster) -&gt; Int {
        :
    }
}
</code></pre>

<p>クラス自体にfinalをつけて、継承を禁止することもできます。</p>

<pre><code>/* モンスタークラス */
final class Monster {
    :
}

// エラー
class Slime: Monster {
}
</code></pre>

<h2 id="イニシャライザ-1">イニシャライザ</h2>

<p>イニシャライザはinitという名の特別なメソッドで、構造体とクラスで初期化のために使用します。Objective-Cのイニシャライザは生成したインスタンスを返す必要がありますが、Swiftの場合は何も返しません。</p>

<p>構造体とクラスのイニシャライザの書き方は基本的に同じですが、それぞれで気をつけるところがあるのでそれらについて以下で説明します。</p>

<h3 id="構造体-1">構造体</h3>

<pre><code>/* パーソン */
struct Person {
    var name: String    // 名前
    var age: Int        // 年齢
    // イニシャライザ
    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
}
let person = Person(name:&quot;タロウ&quot;, age: 18)
</code></pre>

<p>イニシャライザは上の様に関数と違い、initの前にfuncは不要です。また、引数の内部名は自動的に外部名となり（関数で内部名に#をつけたのと同じ）、インスタンスの生成時に引数のラベルをつける必要があります。</p>

<p>構造体の場合は、イニシャライザを記述しないと、プロパティ値を引数にとるイニシャライザ（Memberwise Initialization:メンバワイズイニシャライザといいます。）を自動的に生成してくれます。</p>

<pre><code>/* パーソン */
struct Person {
    var name: String    // 名前
    var age: Int        // 年齢
}
let person = Person(name:&quot;タロウ&quot;, age: 18)
引数のラベルをつけたくない場合は、次のように、外部名に明示的に_（下線）を指定します。


/* パーソン */
struct Person {
    var name: String    // 名前
    var age: Int        // 年齢
    // イニシャライザ
    init(_ name: String, _ age: Int) {
        self.name = name
        self.age = age
    }
}
let person = Person(&quot;タロウ&quot;, 18)
</code></pre>

<p>イニシャライザの重要な役割はプロパティの初期化ですが、プロパティの初期値を宣言時に全て与えている場合に限り、自前でイニシャライザを用意しなくても引数をとらないイニシャライザ（これをデフォルトイニシャライザと言います）を自動的に生成してくれます。この場合でもメンバワイズイニシャライザも使用できます。</p>

<pre><code>/* パーソン */
struct Person {
    var name: String = &quot;&quot;   // 名前
    var age: Int = 0        // 年齢
}
var taro = Person()
taro.name = &quot;タロウ&quot;
taro.age = 18
var hanako = Person(name:&quot;ハナコ&quot;, 16)
</code></pre>

<p>プロパティの宣言時に初期値を与えない場合は、必ずイニシャライザで初期値を与える必要があります。</p>

<pre><code>/* パーソン */
struct Person {
    var name: String
    var age: Int
    init() {
        name = &quot;&quot;
        age = 0
    }
}
</code></pre>

<p>オプショナル型の場合は、宣言時やイニシャライザで初期値を設定しないとnilになります。</p>

<pre><code>/* パーソン */
struct Person {
    var name: String?
    var age: Int
    init() {
        age = 0
    }
}
var person = Person()
println(person.name)        // nil
</code></pre>

<p>自前のイニシャライザを用意する場合は、デフォルトニイシャライザやメンバワイズイニシャライザは自動的に生成されないので必要に応じて全て記述する必要があります。</p>

<pre><code>/* パーソン */
struct Person {
    var name: String = &quot;&quot;
    var age: Int = 0

    // デフォルトイニシャライザ
    init() {}
    // メンバワイズイニシャライザ
    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
    // カスタムイニシャライザ
    init(name: String, birthday: NSDate) {
        // 生年月日から年齢を算出
        let components = NSCalendar.currentCalendar().components(
            .CalendarUnitYear,
            fromDate: birthday,
            toDate: NSDate.date(), options: .allZeros)
        self.init(name: name, age: components.year)
    }
}

let formatter = NSDateFormatter()
formatter.dateFormat = &quot;Y/M/d&quot;
let birthday = formatter.dateFromString(&quot;1965/10/20&quot;)
let person = Person(name: &quot;タロウ&quot;, birthday: birthday!)
</code></pre>

<p>上の例ではコードの重複を避けるため、3つ目のイニシャライザからメンバワイズイニシャライザを呼び出しています。但しこのようにイニシャライザを呼び出すことができるのは、別のイニシャライザの中からのみです。それ以外のメソッドからイニシャライザを呼び出すことはできません。</p>

<p>イニシャライザの中で別のイニシャライザを呼び出す場合、initの呼び出しによってプロパティの初期化が終わるまでselfを使用することはできません。次の様にするとコンパイルエラーになります。</p>

<pre><code>/* パーソン */
struct Person {
    :
    // メンバワイズイニシャライザ
    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
    // カスタムイニシャライザ
    init(name: String, birthday: NSDate) {
        self.name = name                        // initの呼び出し前にselfを使うとエラー
        let age = self.calculateAge(birthday)   // 同上
        self.init(name: name, age: age)         // initのselfはOK
    }
    // 年齢計算
    func calculateAge(birthday: NSDate) -&gt; Int {
        let components = NSCalendar.currentCalendar().components(
            .CalendarUnitYear,
            fromDate: birthday,
            toDate: NSDate.date(), options: .allZeros)
        return components.year
    }
}
</code></pre>

<p>次の様に、年齢計算メソッドを静的メソッドにして、別のイニシャライザの呼び出しの前にselfを使わない様にするとエラーになりません。</p>

<pre><code>/* パーソン */
struct Person {
    :
    // カスタムイニシャライザ
    init(name: String, birthday: NSDate) {
        let age = Pserson.calculateAge(birthday)
        self.init(name: name, age: age)
    }
    // 年齢計算
    static func calculateAge(birthday: NSDate) -&gt; Int {
        :
    }
}
</code></pre>

<p>また、次の様に年齢計算メソッドをイニシャライザの中でネストしたメソッドとして使う方法もあります。この場合、年齢計算メソッドはこのイニシャライザの中からしか呼び出せません。</p>

<pre><code>/* パーソン */
struct Person {
    :
    // カスタムイニシャライザ
    init(name: String, birthday: NSDate) {
         // 年齢計算
        func calculateAge(birthday: NSDate) -&gt; Int {
            let components = NSCalendar.currentCalendar().components(
                .CalendarUnitYear,
                fromDate: birthday,
                toDate: NSDate.date(), options: .allZeros)
            return components.year
        }
        let age = calculateAge(birthday)
        self.init(name: name, age: age)
    }
    :
}
</code></pre>

<h3 id="クラス-1">クラス</h3>

<p><strong>デフォルトイニシャライザ</strong></p>

<p>クラスの場合もデフォルトイニシャライザが用意されています。プロパティの宣言時に初期値を与えているか、オプショナル型の場合に限り、引数をとらないイニシャライザが自動生成されます。</p>

<pre><code>class Person {
    var name: String?
    var age: Int = 0
}
var person = Person()    // name:nil,  age:0
person.name = &quot;タロウ&quot;
person.age = 18
</code></pre>

<p>但し、構造体と異なりメンバワイズイニシャライザは自動生成されません。必要に応じて自分で記述する必要があります。</p>

<pre><code>class Person {
    var name: String?
    var age: Int = 0
}
// 次の呼び出しはエラーになる
var person = Person(name: &quot;タロウ&quot;, age: 0)
</code></pre>

<p><strong>指定イニシャライザとコンビニエンスイニシャライザ</strong></p>

<p>クラスのイニシャライザは、指定イニシャライザとコンビニエンスイニシャライザに大別されます。
指定イニシャライザはそのクラスの中心となるイニシャライザで、通常は全てのプロパティの初期化を行うような処理を担います。一方、コンビニエンスイニシャライザは補佐的なイニシャライザで、呼び出し方を簡便にしたり、別の引数を与えて初期化を行うような場合に使用します。クラスには最低1つ以上の指定イニシャライザが必要です。またコンビニエンスイニシャライザからは最終的に指定イニシャライザを呼び出す様にします。</p>

<blockquote>
<p>デフォルトイニシャライザは指定イニシャライザです。</p>
</blockquote>

<p>コンビニエンスイラシャライザはinitの前に、convenienceをつけて宣言します。</p>

<pre><code>/* パーソン */
class Person {
    var name: String
    var age: Int
    // 指定イニシャライザ
    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
    // コンビニエンスイニシャライザ
    convenience init(name: String, birthday: NSDate) {
        // 生年月日から年齢を算出
        let components = NSCalendar.currentCalendar().components(
            .CalendarUnitYear,
            fromDate: birthday,
            toDate: NSDate.date(), options: .allZeros)
        // 指定イニシャライザの呼び出し
        self.init(name: name, age: components.year)
    }
}
</code></pre>

<p>指定イニシャライザとコンビニエンスイニシャライザ間の関係は、以下のルールに従う必要があります。</p>

<p><strong>ルール1</strong>
サブクラスの指定イニシャライザは、直近の親クラスの指定イニシャライザを呼ばなくてはならない。
<strong>ルール2</strong>
コンビニエンスイニシャライザは、同じクラスの他のイニシャライザを呼ばなくてはならない。
<strong>ルール3</strong>
コンビニエンスイニシャライザは、最終的に（呼び出すニイシャライザのどこかで）指定イニシャライザを呼ばなくてはならない。</p>

<p>つまり、最終的に継承ツリーの中の全てのクラスの指定イニシャライザが呼ばれる必要があります。</p>

<p>init_delegate.png
2フェーズの初期化</p>

<p>クラスの初期化は、2フェーズのプロセスで構成されます。</p>

<p>2フェーズの構成にすることで、値が未設定のプロパティにアクセスしたり、設定した値が他のイニシャライザの呼び出しによって別の値に上書きされることを防ぐことができます。</p>

<p>コンパイラは次のセーフティチェックを行います。</p>

<p>セーフティチェック1
指定イニシャライザがスーバークラスのイニシャライザを呼ぶ前に、そのクラス自身のプロパティを全てに初期値を与えているか？
セーフティチェック2
指定イニシャライザの中で、継承したプロパティに値を設定する前にスーパークラスのイニシャライザを呼んでいるか？（スーパークラスのイニシャライザを後から呼ぶと、その前に設定したプロパティが上書きされてしまう）
セーフティチェック3
コンビニエンスイニシャライザの中でプロパティの設定をする前に、そのクラスの別のイニシャライザを呼んでいるか？（イニシャライザを後から呼ぶと、その前に設定したプロパティがそのクラスの指定イニシャライザによって上書きされてしまう）
セーフティチェック4
フェーズ1が終わる前に、インスタンスメソッド、インスタンスプロパティ、selfへのアクセスをしていないか？（初期値の設定が済んでいないのでフェーズ1が終わるまでselfにアクセスできない）
フェーズ1とフェーズ2はそれぞれ次のような流れになります。</p>

<p>フェーズ1</p>

<p>クラスの指定イニシャライザ、又はコンビニエンスイニシャライザが呼ばれる。
インスタンス用のメモリが確保される。この時点ではまだメモリは初期化されていない。
指定イニシャライザの呼び出し完了時点でそのクラスの保持型プロパティの初期値が全て与えられる。インスタンスの初期化が完了する。
スーパークラスのプロパティに初期値を与えるため、スーパークラスの指定イニシャライザ呼び出す。
継承ツリーの最初のクラスに達するまで指定イニシャライザの呼び出しが繰り返される。
ベースクラスの指定イニシャライザの実行が終わると全てのプロパティに初期値が与えられたことになり、ここまででフェーズ1が完了する。
フェーズ2</p>

<p>ベースクラスの指定イニシャライザの呼び出しが終わり、継承ツリーを下る過程で、各クラスのイニシャライザの中で必要に応じて追加の処理が行われる。この時点では、selfへのアクセスも可能となる。
最終的に、継承ツリーの最下部のクラスのコンビニエンスイニシャライザの呼び出しまで戻り、最終的な処理が行われ、全てのイニシャライザの呼び出しが完了する。
init_delegate2.png</p>

<h3 id="イニシャライザの自動継承">イニシャライザの自動継承</h3>

<p>ある条件の元では、スーパークラスのイニシャライザが自動的にサブクラスに継承されます。それは次の場合です。</p>

<p><strong>条件1</strong>
サブクラスで指定イニシャライザを定義しない場合、スーパークラスの指定イシニャライザがそのまま継承される。
<strong>条件2</strong>
条件1による自動継承、或いは独自イニシャライザの提供に関わらず、スーパークラスの指定イニシャライザを全てサブクラスで定義すると、スーパークラスのコンビニエンスイニシャライザは自動的に全て継承される。これは、スーパークラスに無い新たなコンビニエンスイニシャライザを別途追加したとしても同様。</p>

<h3 id="イニシャライザの継承">イニシャライザの継承</h3>

<p>ここまでの説明を踏まえてサンプルコードを以下に示します。</p>

<p>まずベースクラスです。ここではレンタル商品のクラスをベースクラスとします。レンタル商品クラスは商品名、価格、レンタル期間をプロパティに持ちます。
そして、2つの指定イニシャライザと1つのコンビニエンスイニシャライザを持ちます。指定イニシャライザの1つは中身が空ですが、プロパティは全て初期値を与えているかオプショナル型なので、initの中で初期値を与えなくてもエラーになりません。
コンビニエンスイニシャライザからは指定イニシャライザを呼び出しています。（ルール2）</p>

<pre><code>/* レンタル商品 */
class RentalGoods {
    var name: String?   // 品目名
    var price: Int = 0  // 価格
    var term: (startDate:NSDate, days:Int)?     // レンタル期間（開始日, 日数）
    // 指定イニシャライザ
    init() {}
    // 指定イニシャライザ
    init(name: String, price: Int, term: (NSDate, Int)) {
        self.name = name
        self.price = price
        self.term = term
    }
    // コンビニエンスイニシャライザ
    convenience init(name: String, price: Int, days: Int) {
        // 今日を開始日とする
        self.init(name:name, price:price, term:(NSDate.date(), days))
    }
    // 内容出力
    func printDescription() {
        let dateFormatter = NSDateFormatter()
        dateFormatter.dateFormat = &quot;yyyy/MM/dd&quot;
        print(&quot;商品名:\(name!)\t価格:\(price)円\tレンタル期間:\(dateFormatter.stringFromDate(term!.startDate))から\(term!.days)日間&quot;)
    }
}
</code></pre>

<p>次に、レンタル商品クラスを継承して、インターネットでレンタルできるネットレンタル商品（デジタル商品）を表すクラスをつくったとします。ここでは、名前をNetRentalGoodsとします。
新たなプロパティとして、容量を表すsizeプロパティと、容量の単位を表すunitプロパティを追加します。</p>

<p>引数を取らないイニシャライザはスーパークラスのイニシャライザをオーバーライドするので、overrideを指定します。sizeプロパティは宣言時に初期値を与えていないので、スーバークラスのイニシャライザを呼び出す前に設定する必要があります。（フェーズ1）
unitプロパティは宣言時に初期値を与えているのでイニシャライザの中で設定する必要はありません。</p>

<p>また、指定イニシャライザの中で、スーパークラスの指定イニシャライザを呼び出しています。（ルール1）</p>

<p>そして、コンビニエンスイニシャライザからは、自身の指定イニシャライザを呼び出しています。（ルール3）</p>

<pre><code>/* ネットレンタル商品 */
class NetRentalGoods: RentalGoods {
    var size: Float                 // 容量（MByte）
    var unit: String = &quot;MByte&quot;      // 単位
    // 指定イニシャライザ
    override init() {
        self.size = 0
        super.init()
    }
    // 指定イニシャライザ
    init(name: String, price: Int, term: (NSDate, Int), size: Float) {
        self.size = size
        super.init(name: name, price: price, term: term)
    }
    // コンビニエンスイニシャライザ
    convenience init(name: String, price: Int, days: Int, size: Float) {
        self.init(name: name, price: price, term: (NSDate.date(), days), size:size)
    }
    // 内容出力
    override func printDescription() {
        super.printDescription()
        let s = String(format: &quot;%.2f&quot;, size) + unit
        print(&quot;容量:\(s)&quot;)
    }
}
</code></pre>

<p>最後に、ネットレンタル商品クラスを継承して、映画レンタル商品クラスを作成します。</p>

<p>新たなプロパティとして、監督（producer）、主演俳優（leadingActors）、上映時間（screenTime）を追加しました。ここではプロパティの宣言時に初期値を与えず、指定イニシャライザの中で設定しています。ここでも上の場合と同じ酔うに、自クラスのプロパティの初期値設定は、スーパークラスのイニシャライザの呼び出し（super.init(〜)）の前に行っています。</p>

<p>さらに、指定イニシャライザの中で価格を変更したり別のメソッドを呼び出しています。このように、スーパークラスがもつプロパティに値を設定したり、他のメソッドを呼び出す場合は、必ずスーパークラスのイニシャライザの呼び出しが終わった後（フェーズ2）で行う必要があります。上で説明したように、フェーズ1が完了するまでインスタンスの内容が適切に初期化されていないためです。また、設定の後にイニシャライザ呼び出すと設定した値が上書きされてしまいます。</p>

<blockquote>
<p>フェーズ2であってもスーパークラスの定数を上書きすることはできません。</p>
</blockquote>

<p>下の例ではネットレンタル商品クラスの指定イニシャライザをオーバーライドしてコンビニエンスイニシャライザを定義しています。このように、スーバークラスの指定イニシャライザをコンビニエンスイニシャライザとしてオーバーライドすることも可能です。その場合は、override convenienceと宣言します。</p>

<pre><code>/*　映画ネットレンタル商品 */
class MovieRentalGoods: NetRentalGoods {
    var producer: String           // 監督
    var leadingActors: String      // 主演俳優
    var screenTime: Int            // 上映時間
    // 指定イニシャライザ
    override init() {
        // フェーズ1
        self.producer = &quot;&quot;
        self.leadingActors = &quot;&quot;
        self.screenTime = 0
        super.init()
        // フェーズ2
        self.price = 500
        self.adjustSizeUnit()
    }
    // 指定イニシャライザ
    init(name: String, price: Int, term: (NSDate, Int), size: Float, producer: String, leadingActors: String, screenTime: Int) {
        // フェーズ1
        self.producer = producer
        self.leadingActors = leadingActors
        self.screenTime = screenTime
        super.init(name: name, price: price, term: term, size: size)
        // フェーズ2
        self.adjustSizeUnit()
    }
    // コンビニエンスイニシャライザ
    override convenience init(name: String, price: Int, term: (NSDate, Int), size: Float) {
        self.init(name: name, price: price, term: term, size: size, producer: &quot;&quot;, leadingActors: &quot;&quot;, screenTime: 0)
    }
    // サイズの単位の変更
    func adjustSizeUnit() {
        if (self.size &gt; 1024) {
            self.size /= 1024
            self.unit = &quot;GByte&quot;
        }
    }
    // 内容出力
    override func printDescription() {
        super.printDescription()
        print(&quot;監督:\(producer)\t主演俳優:\(leadingActors)\t上映時間:\(screenTime)分&quot;)
    }
}

let movie = MovieRentalGoods(name: &quot;ローマの休日&quot;, price: 400, days: 2, size: 3600)
movie.producer = &quot;ウィリアム・ワイラー&quot;
movie.leadingActors = &quot;オードリーヘップバーン, グレゴリーベック&quot;
movie.screenTime = 118
movie.printDescription()
/*
商品名:ローマの休日	価格:400円	レンタル期間:2014/09/02から2日間
容量:3.52GByte
監督:ウィリアム・ワイラー	主演俳優:オードリーヘップバーン, グレゴリーベック	上映時間:118分
*/
</code></pre>

<p>上の映画ネットレンタル商品クラスでは、スーパークラスの2つの指定イニシャライザをオーバーライドしているので、スーバークラスのコンビニエンスイニシャライザも自動的に継承され呼び出すことができています。（イニシャライザの自動継承の条件2）
もし、ネットレンタル商品クラスのコンビニエンスイニシャライザを再定義する場合、ルール2の制約により、再定義したイニシャライザからスーパークラスのコンビニエンスイニシャライザを呼び出すことはできません。その場合、映画ネットレンタル商品クラスの指定イニシャライザを呼び出す必要があります。またこの場合、overrideの指定はできません。</p>

<p>init_delegate3.png</p>

<h3 id="必須イニシャライザ">必須イニシャライザ</h3>

<p>イニシャライザの前にrequiredをつけて宣言した場合、そのクラスを継承するサブクラスは必ずそのイニシャライザを実装する必要があります。但し、そのイニシャライザが自動的に継承される場合は明示的に実装する必要はありません。
サブクラスで実装する場合、そのイニシャライザの前にもrequiredをつけて宣言する必要があります。その場合、overrideは不要です。</p>

<pre><code>/* ラベル */
class Label {
    var title: String   // タイトル
    var width: Int      // 幅
    var height: Int     // 高さ
    // 指定イニシャライザ
    required init(title: String, width: Int, height: Int) {
        self.title = title
        self.width = width
        self.height = height
    }
}

/* ボタン（これはエラー） */
class Button: Label {
    var pushed: Bool    // 押された？
    // 指定イニシャライザ
    init(title: String, width: Int, height: Int, pushed: Bool) {
        // 必須イニシャライザの実装が無いのでコンパイルエラー
        super.init(title, width, height)
    }
}

// ↓ならOK
/* ボタン */
class Button: Label {
    var pushed: Bool    // 押された？
    // 指定イニシャライザ
    required init(title: String, width: Int, height: Int) {
        self.pushed = false
        super.init(title: title, width: width, height: height)
    }
    // コンビニエンスイニシャライザ
    convenience init(title: String, width: Int, height: Int, pushed: Bool) {
        self.init(title: title, width: width, height: height)
        self.pushed = pushed
    }
}
</code></pre>

<h3 id="関数オブジェクトによるプロパティの初期化">関数オブジェクトによるプロパティの初期化</h3>

<p>次の例の様に、プロパティの宣言時に関数の呼び出し結果を使うことができます。squaresプロパティに無名関数オブジェクトを設定し最後に()をつけて呼び出しています。()がないと、関数の戻り値ではなく、関数オブジェクトそのものを割り当てることになり型が合わないためコンパイルエラーが発生します。</p>

<pre><code>/*
  ビンゴカード
  5 x 5 のマス目にランダムに割り当てられた1〜25の数値を持つ
*/
struct BingoCard {
    // 各マス目の番号配列（関数オブジェクトを呼び出して初期化）
    let squares: [Int] = {
        var numbers = [Int]()
        for i in 1...25 {
            numbers.append(i)
        }
        var array = [Int]()
        while !numbers.isEmpty {
            let idx = Int(arc4random()) % numbers.count
            array.append(numbers.removeAtIndex(idx))
        }
        return array
    }()
    // 指定マス目の番号を返す
    subscript(index: Int) -&gt; Int {
        return squares[index]
    }
    // 全ての番号を出力
    func printNumbers() {
        for var idx=0; idx&lt;squares.count; idx++ {
            print(&quot;\(self[idx])\t&quot;, , terminator: &quot;&quot;))
            if (idx + 1) % 5 == 0 {
                print(&quot;&quot;)
            }
        }
    }
}

let card = BingoCard()  // ビンゴカードのインスタンスを生成
card.printNumbers()     // 番号を出力
/* 出力結果例
14	22	10	6	11
1	20	9	5	2
19	23	4	21	18
3	15	7	8	17
25	12	24	13	16
*/
</code></pre>

<blockquote>
<p>プロパティの宣言に使用する関数オブジェクトの呼び出し中はまだインスタンスの初期化が完了していないため、関数オブジェクトの中で他のプロパティにアクセスしたり、selfを使うことはできません。</p>
</blockquote>

<h2 id="デイニシャライザ-1">デイニシャライザ</h2>

<p>デイニシャライザはクラスのインスタンスが破棄される時に自動的に呼ばれる特殊なメソッドです。構造体にデイニシャライザはありません。
メモリに確保されたインスタンスやプロパティはARC（Automatic reference counting）によって自動的に破棄されるので通常はデイニシャライザを記述する必要はありませんが、例えばファイルを扱うクラスで、開いたファイルをインスタンスの破棄時に確実に閉じるためにデイニシャライザを利用することができます。</p>

<p>デイニシャライザは次のように、deinitという名のメソッドです。deinitの後の()（かっこ）は不要です。</p>

<pre><code>deinit {
    // 後始末
}
</code></pre>

<p>デイニシャライザを明示的に呼び出すことはできません。また、スーバークラスのデイニシャライザも、サブクラスから呼び出す必要はありません。これらはサブクラスでデイニシャライザを定義する、しないに関わらず自動的に呼ばれます。</p>

<p>デイニシャライザの呼び出しが完了するまでインスタンスは破棄されません。なので、デイニシャライザの中でプロパティやselfにアクセスすることも可能です。</p>

<p>次の例では、クライアントクラスのイニシャライザでリソースマネージャから取得したリソースを、デイニシャライザで解放しています。</p>

<pre><code>/* リソースマネージャ */
class ResourceManager {
    // リソースを獲得してリソースIDを返す。
    class func getResource(filePath: String) -&gt; Int {
        var resourceId: Int
        // リソースを獲得する処理
        return resourceId;
    }
    class func releaseResource(resourceId: Int) {
        // リソースを解放する処理
    }
}

/* クライアントクラス　*/
class Client {
    var resourceId: Int
    // イニシャライザ
    init(filePath: String) {
        resourceId = ResourceManager.getResource(filePath)
    }
    // デイニシャライザ
    deinit {
        ResourceManager.releaseResource(resourceId)
    }
}
</code></pre>

<h2 id="arc">ARC</h2>

<p>Swiftではクラスのインスタンスは、Objective-Cと同様、参照カウンタで管理されています。</p>

<p>インスタンスが初めて生成された時に参照カウントが1になり、以降そのインスタンスへの参照が増えると参照カウントがインクリメントされ、減るとデクリメントされます。そして、参照カウントが0になると、インスタンスも自動的に破棄されます。</p>

<p>ARCは、Automatic Reference Countingの略で、参照カウントの増減を自動的にやってくれる仕組みのことです。
ARCはObjective-Cでも利用でき、ARCの登場以前は、プログラマがインスタンスへの参照が増えるたびに、参照カウントを増やし、参照を減らすたびに、参照カウントを減らすということをプログラムで意識して管理していましたが、ARCによって参照カウントの管理が自動化され、処理の記述漏れによるメモリリークをほとんどのケースで気にせずコーディングできるようになりました。</p>

<blockquote>
<p>参照カウンタで管理されるのはクラスのインスタンスのみです。構造体や列挙型に参照カウンタはありません。</p>
</blockquote>

<p><strong>強参照</strong></p>

<p>クラスのインスタンスを生成すると、そのインスタンスの参照カウントは1になります。別の変数へコピーすると参照カウントが増えて2になります。変数にnilを代入して破棄すると、参照カウントが1減ります。参照カウントが0になるとインスタンスも破棄されます。
このように参照カウントを増減する参照をstrong reference（強参照）と呼びます。強参照により参照カウントが0より大きい間は、インスタンスが破棄されることはありません。
特に明記しない限りクラスのインスタンスは強参照となります。</p>

<p>具体例を以下にコードで示します。</p>

<pre><code>/* ペットクラス */
class Pet {
    let name: String
    init(name: String) {
        self.name = name
        print(&quot;ペット（\(self.name)）の生成&quot;)
    }
    deinit {
        print(&quot;ペット（\(self.name)）の破棄&quot;)
    }
}

var pochi1, pochi2, pochi3: Pet?
pochi1 = Pet(name: &quot;ポチ&quot;) // 参照カウント:1
/* 実行結果
   ペット（ポチ）の生成
*/

pochi2 = pochi1          // 参照カウント:2
pochi3 = pochi1          // 参照カウント:3
pochi1 = nil             // 参照カウント:2
pochi2 = nil             // 参照カウント:1
pochi3 = nil             // 参照カウント:0 ==&gt; インスタンスの破棄
/* 実行結果
   ペット（ポチ）の破棄
*/
</code></pre>

<blockquote>
<p>Playgroundではインスタンス破棄のタイミングが不定なためか、上のコードをPlaygroundで実行してもデイニシャライザが呼ばれません。</p>
</blockquote>

<p><strong>循環参照</strong></p>

<p>関連のある複数のクラスのインスタンス同士をお互いに強参照で保持すると、循環参照となりメモリリーク（インスタンスが破棄されずに残ること）する場合があります。
以下に例を示します。</p>

<pre><code>/* 船クラス */
class Ship {
    let name: String
    var captain: Captain?    // 船長
    init(name: String) {
        self.name = name
    }
    deinit {
        print(&quot;船（\(self.name)）の破棄&quot;)
    }
}

/* 船長クラス */
class Captain {
    let name: String         // 船
    var ship: Ship?
    init(name: String) {
        self.name = name
    }
    deinit {
        print(&quot;船長（\(self.name)）の破棄&quot;)
    }
}

var merry: Ship? = Ship(name: &quot;ゴーイングメリー号&quot;)
var rufy: Captain? = Captain(name: &quot;ルフィ&quot;)
merry!.captain = rufy
rufy!.ship = merry
</code></pre>

<p>ここまでで、以下の図のような状態になっています。</p>

<p>ここで、merry変数にnilを設定すると、次のように船クラスのインスタンスの参照カウントが1減って1になります。まだ船長クラスから参照されているので0にはなりません。</p>

<pre><code>merry = nil
</code></pre>

<p>次に、rufy変数にnilを設定します。すると次のように、船長クラスの参照カウントが1減って1になります。</p>

<pre><code>rufy = nil
</code></pre>

<p>船クラスと船長クラスのインスタンスがお互いにそれぞれのインスタンスを保持し合っているため、参照カウントが0にならずメモリに残ったままになっています。
それぞれのインスタンスを指す変数はもうnilが代入されているので、これらのインスタンスにアクセスする手段は無く宙ぶらりんの状態で不要にメモリを占有しメモリリークしています。</p>

<p>このような循環参照を避けるには、少なくとも一方のクラスで強参照を使わず参照カウントに影響を与えないようにする必要があります。
Swiftではこのような場合に利用できる2種類の参照方法があります。1つが弱参照と呼ばれるもので、もう1つがアンオウンド参照（unowned：所有しないという意味）と呼ばれるものです。</p>

<p>参照するインスタンスが後からnilになるうる場合は弱参照を、一旦設定されたらその後nilになることがない（インスタンスの存続期間が一方に、或はお互いに依存する）場合はアンオウンド参照を使用します。</p>

<p><strong>弱参照</strong></p>

<p>参照先を設定した後その値がnilになり得る場合は弱参照を使います。上の例では、船長がやめたり別の船に乗り換えたりしてnilになるケースもあり得るので、弱参照を使うのが適しています。</p>

<p>弱参照を使うと指定先のインスタンスを保持せず、そのインスタンスが破棄された時は自動的にnilが代入されます。弱参照を使うには、プロパティの宣言時にweakをつけて宣言します。
また、値としてnilを許容する必要があるので型はオプショナル型である必要があります。上の例の場合はもともとオプショナル型にしていました。</p>

<pre><code>/* 船クラス */
class Ship {
    let name: String
    weak var captain: Captain?
    init(name: String) {
        self.name = name
    }
    deinit {
        print(&quot;船（\(self.name)）の破棄&quot;)
    }
}

/* 船長クラス */
class Captain {
    let name: String
    var ship: Ship?
    init(name: String) {
        self.name = name
    }
    deinit {
        print(&quot;船長（\(self.name)）の破棄&quot;)
    }
}

var merry: Ship? = Ship(name: &quot;ゴーイングメリー号&quot;)
var rufy: Captain? = Captain(name: &quot;ルフィ&quot;)
merry!.captain = rufy
rufy!.ship = merry
</code></pre>

<p>必要に応じて船長クラスの船インスタンスを参照するプロパティもweakにしても良いのですが、一方をweakにするだけでも循環参照を回避することは可能です。</p>

<p>ここまでで、参照カウントは次のようになります。</p>

<p>船クラスの船長プロパティを弱参照にしたため、船長クラスのインスタンスの参照カウントは、rufy変数から参照されている1つのみとなっています。</p>

<p>ここで、mery変数にnilを代入すると次のようになります。</p>

<p>船クラスのインスタンスの参照カウントが1減って1になりました。この後、残ったrufy変数にnilを代入すると、船長クラスのインスタンスの参照カウントは0になり破棄されます。同時に、船長クラスのインスタンスが参照していた船クラスのインスタンスの参照カウントが1減って0になるため、船クラスのインスタンスも破棄されます。</p>

<p>逆に、最初の状態からmery変数にnilを代入する前に、rufy変数にnilを代入した場合、次のようになります。</p>

<p>船長クラスのインスタンスは最初の状態で参照カウントが1だったため、rufy変数にnilを代入した結果、船長クラスのインスタンスの参照カウントが0になり、船長クラスのインスタンスは破棄されます。
そして、船クラスのインスタンスへの参照カウントが1減って、1になります。また、船クラスのインスタンスが参照する船長クラスのインスタンスへのプロパティは弱参照となっているため、船長クラスのインスタンスの破棄に伴いnilが設定されます。</p>

<p>船クラスの船長プロパティには自動的にnilに設定されるので、次のようなコードで安全にプロパティにアクセスすることができます。</p>

<pre><code>if let captain = merry?.captain {
    print(captain.name)
}
</code></pre>

<p>この後は、mery変数にnilを代入することで、船クラスのインスタンスの参照カウントが0になり破棄されます。</p>

<p>これでメモリリークすることはなくなりました。</p>

<blockquote>
<p>この結果も最初の例と同じようにPlaygroundでは検証できません。インスタンスの破棄によるデイニシャライザの出力結果を確認したい場合は、プロジェクトファイルを作ってシミュレータで動かす等して確認するか、REPL上で確認する必要があります。</p>
</blockquote>

<p><strong>アンオウンド参照</strong></p>

<p>アンオウンド参照は、プロパティが一旦設定されたら、その後nilになることはないような場合に使用します。つまりそのプロパティのクラスに強く結びついていて、プロパティが先に破棄されることがないような場合です。
例を以下に示します。</p>

<pre><code>/* パーソンクラス */
class Person {
    let name: String    // 氏名
    var drivingLicence: DrivingLicense? // 運転免許証
    init(name: String) {
        self.name = name
    }
    deinit {
        print(&quot;バーソン（\(self.name)）の破棄&quot;)
    }
}

/* 運転免許証クラス */
class DrivingLicense {
    var number: Int64           // 免許証番号
    unowned var holder: Person  // 所有者
    init(number: Int64, holder: Person) {
        self.number = number
        self.holder = holder
    }
    deinit {
        print(&quot;運転免許証（\(self.number)）の破棄&quot;)
    }
}
</code></pre>

<p>ここでは、運転免許証とそれを保持するパーソンのクラスを使っています。バーソンは運転免許証を持たない可能性がありますが、運転免許証は必ず所有者がいるので、運転免許証クラスの所有者プロパティはnilになることはありません。そのため、unownedをつけてアンオウンド参照として宣言しています。また所有者プロパティはnilになることはないので、オプショナル型にはしていません。対してパーソンクラスの運転免許証プロパティはオプショナル型として宣言してあります。</p>

<p>アンオウンド参照も、弱参照と同様インスタンスの参照カウントに影響しません。またそのインスタンスが破棄された場合でもプロパティに自動的にnilが設定されることもありません。つまり、プロパティが先に破棄されることのないような状況で使用します。もし、プロバティが先に破棄されて、そのプロパティにアクセスすると、実行時エラーが発生します。</p>

<p>これらのインスタンスを生成してみます。</p>

<pre><code>var taro: Person? = Person(name: &quot;山野タロウ&quot;)
taro!.drivingLicence = DrivingLicense(number: 235_3421_0897_1025, holder: taro!)
</code></pre>

<p>運転免許証クラスの所有者プロパティをアンオウンドとしたので、パーソンクラスのインスタンスの参照カウントはtaro変数からの参照1つのみです。
この状態でtaro変数にnilを代入すると、パーソンクラスのインスタンスの参照カウントは0になり破棄されます。合わせてパーソンクラスのインスタンスから参照していた、運転免許証クラスのインスタンスも破棄されます。メモリーリークは起こりません。</p>

<p>もう１つの例を見てみます。上の例では、お互いを参照するクラスの一方はそのプロパティがnilになり得るが、もう一方はnilになり得ないという場合でした。
次に見る例は、お互いが強く結びついているため、参照する両方のプロパティがnilになり得ないというケースです。</p>

<p>ここでは、会社と社長という関係を使います。会社と社長はお互いに関連を持ち、それぞれ関連が無くなるということはあり得ません。つまりこれら2つのクラスのインスタンスを作成し、プロパティにお互いを設定した後はnilにすることはあり得ません。</p>

<pre><code>/* 社長クラス */
class CompanyPresident {
    let name: String                // 氏名
    unowned let conpany: Company    // 会社
    init(name: String, company: Company) {
        self.name = name
        self.conpany = company
    }
    deinit {
        print(&quot;社長（\(self.name)）の破棄&quot;)
    }
}

/* 会社クラス */
class Company {
    let name: String                    // 会社名
    let president: CompanyPresident!    // 社長
    init(name: String, presidentName: String) {
        self.name = name
        self.president = CompanyPresident(name: presidentName, company: self)
    }
    deinit {
        print(&quot;会社（\(self.name)）の破棄&quot;)
    }
}

var company: Company? = Company(name: &quot;りんごカンバニー&quot;, presidentName: &quot;スティーブ・ゲイツ&quot;)
</code></pre>

<p>図としてはその前の、パーソンと運転免許証クラスの図と同様です。循環参照を避けるために、社長クラスの会社プロパティをアンオウンド参照としています。会社プロパティはnilを許容しないので、ここではオプショナル型にはしていません。社長クラスのイニシャライザで社長名と会社インスタンスを受け取り、それをプロパティに設定しています。</p>

<p>会社クラスの方の実装は少し違っています。今回は会社クラスの社長プロパティもnilに出来ないので、イニシャライザで社長名を受け取り、社長クラスのインスタンスを生成してプロパティに設定しています。
ここで問題になるのは、社長クラスのイニシャライザに渡すためにselfが必要になるということです。イニシャライザの章で説明しましたが、selfにアクセスできるのは、インスタンスプロパティの設定が全て終わった後です。しかし、ここではそのプロパティの設定のためにselfが必要になるので、selfを使うに使えないというジレンマが発生します。
nilを許容するプロパティであればオプショナル型とすることで、初期値がnilで初期化済みになるので問題なくselfを使うことができますが、この場合はnilを許容しない方針なのでオプショナル型にするわけにもいきません。</p>

<p>そこで、ここでは社長プロパティを「暗黙的なオプショナル型」として宣言しています。「暗黙的なオプショナル型」はnilを許容する型なので、それ以外のプロパティの初期化が完了していればselfを安全に使うことができます。また、「暗黙的なオプショナル型」は実際にアクセスする時までには値が設定されている（nilではない）想定で使用する型なので、nilを許容しないという条件も満たすことができます。「暗黙的なオプショナル型」を使用することで、アンラップすることなく、社長プロパティにアクセスすることができます。</p>

<pre><code>print(company!.president.name)    // スティーブ・ゲイツ
/* 注意:company変数は上でオプショナル型として宣言したのでアンラップが必要です。presidentプロパティは「暗黙的なオプショナル型」なのでアンラップは不用です。*/

company = nil  // インスタンスを破棄
</code></pre>

<p><strong>クロージャの循環参照</strong></p>

<p>クラスインスタンス同士の参照以外にも循環参照を引き起こすケースがあります。それは、クラスのプロパティにクロージャを割り当て、その中でselfを参照するような場合です。クロージャもクラスインスタンスと同様参照型なので現象としては同じです。</p>

<pre><code>/* パスワード生成器クラス */
class PasswordGenerator {
    // パスワードの長さ
    var length: Int
    // 使用可能文字
    var allowedCharacters: [Character] {
        var charas = [Character]()
        // ASCII文字 &quot;0&quot;〜&quot;}&quot;
        for ch in 0x30...0x7d {
            charas.append(Character(UnicodeScalar(ch)))
        }
        return charas
    }
    // パスワードの生成
    lazy var newPassword: () -&gt; String = {
        var pass = &quot;&quot;
        for idx in 1...self.length {
            let ch = self.allowedCharacters[Int(arc4random()) % self.allowedCharacters.count]
            pass.append(ch)
        }
        return pass
    }
    // イニシャライザ
    init(length: Int) {
        self.length = length
    }
}

var passwordGenerator: PasswordGenerator? = PasswordGenerator(length: 8)

print(passwordGenerator!.newPassword())

passwordGenerator = nil     // !!!メモリリーク
</code></pre>

<p>上の例はパスワードを生成するためのクラスで、パスワード生成のロジックを変更できるようにパスワードを取得するためのプロパティをクロージャにしています。
このクロージャでは、selfを使ってインスタンスのプロパティにアクセスしています。クロージャは使用する外部のインスタンスをデフォルトで強参照で保持します。そのため下図の様に「インスタンス→クロージャ」、「インスタンス←クロージャ」という循環参照が発生しています。</p>

<p>このため、passwordGenerator変数にnilを代入しても、パスワード生成器のインスタンスもクロージャのインスタンスもメモリから破棄されません。</p>

<p>Swiftではこの様な状況を解決するために、キャプチャリストというものが提供されています。</p>

<p>キャプチャリストを使ってクロージャ内で使用するインスタンスの参照方法を指定することができます。キャプチャリストはweakやunownedといった参照方法とそのインスタンスのペアをカンマ区切りで指定するものです。</p>

<p>例えば、Int型とString型の引数をとりString型を返すクロージャ内で参照するselfをアンオウンド参照としたい場合は次のように記述します。</p>

<pre><code>    lazy var someProperty: (Int, String) -&gt; String = {
        [unowned self](number: Int, text: String) -&gt; String in
        :
    }
</code></pre>

<p>また、引数を取らずString型を返すクロージャ内で参照するselfを弱参照としたい場合は次のように記述します。</p>

<pre><code>    lazy var someProperty: () -&gt; String = {
        [weak self] in   // 戻り値の型は宣言から類推される
        :
    }
</code></pre>

<p>弱参照にするかアンオウンド参照にするかは、クラスのインスタンスプロパティ同士の場合と同じように、2つの依存度が高くインスタンスの破棄に合わせてクロージャも破棄する場合はアンオウンド参照を、後からプロパティにnilを設定したり、クラスインスタンスの破棄後もクロージャが存続する可能性がある場合は弱参照を使うようにします。</p>

<p>上のパスワード生成器クラスのクロージャをアンオウンド参照にして循環参照を回避するようにしてみます。</p>

<pre><code>/* パスワード生成器クラス */
class PasswordGenerator {
    // パスワードの長さ
    var length: Int
    // 使用可能文字
    var allowedCharacters: [Character] {
        var charas = [Character]()
        // ASCII文字 &quot;0&quot;〜&quot;}&quot;
        for ch in 0x30...0x7d {
            charas.append(Character(UnicodeScalar(ch)))
        }
        return charas
    }
    // パスワードの生成
    lazy var newPassword: () -&gt; String = {
        [unowned self] in
        var pass = &quot;&quot;
        for idx in 1...self.length {
            let ch = self.allowedCharacters[Int(arc4random()) % self.allowedCharacters.count]
            pass.append(ch)
        }
        return pass
    }
    // イニシャライザ
    init(length: Int) {
        self.length = length
    }
}
</code></pre>

<p>newPasswordプロパティのクロージャの最初に[unowned self] inを追記しただけです。
これにより、クロージャからselfへの参照が強参カウントへの影響を与えないアンオウンド参照となり、循環参照を回避することができます。</p>

<h2 id="オプショナルの連鎖">オプショナルの連鎖</h2>

<p>オプショナル型のプロパティにアクセスする場合、プロパティの後ろに ! をつけてアンラップが必要になります。</p>

<pre><code>class Person {
    let name: String
    let friends: [Person]?
    init(name: String) {
        self.name = name
    }
}

let taro = Person(name: &quot;タロウ&quot;)
print(taro.friends!.count)
</code></pre>

<p>ところが、オプショナル型のプロパティがnilの場合、アンラップすると実行時エラーになります。これを回避するには、オプショナルバインディングで事前に確認する方法があります。</p>

<pre><code>if let friends = taro.friends {
    print(friends.count)
}
</code></pre>

<p>オプショナルの連鎖を使うと、これをもう少し簡単に記述することができます。
オプショナルの連鎖では、プロパティの後ろに、 ! の代わりに ? をつけてアクセスします。そして、もしそのプロバティがnilだった場合、エラーになるのではなく、nilが返されます。</p>

<pre><code>print(taro.friends?.count)    // nil
</code></pre>

<p>オプショナルの連鎖から返される型は、期待する型のオプショナル型です。これはnilが返される可能性があるからです。上の例の場合、配列のcountプロパティはInt型なので、Intのオプショナル型（Int?）が返されます。</p>

<p>次のように、取得した値をオプショナルバインディングを使ってアンラップできます。</p>

<pre><code>if let count = taro.friends?.count {
    print(count)
}
</code></pre>

<p>次はもう少し複雑な例をみてみます。</p>

<p>映画館、映画館の中の各スクリーン、各スクリーンで上映する映画と座席数という、以下の図のような関連を考えます。</p>

<p>これらのクラスをコードで記述してみます。</p>

<pre><code>/* 映画館クラス */
class MovieTheater {
    let name: String            // 名称
    var screens: [Screen]?      // スクリーン
    // イニシャライザ
    init(_ name: String) {
        self.name = name
    }
}

/* スクリーンクラス */
class Screen {
    var movie: Movie?           // 映画
    var sheets: [Bool]          // 座席
    // 各座席にアクセスするためのサブスクリプト
    subscript(idx: Int) -&gt; Bool {
        get {
            return sheets[idx]
        }
        set {
            sheets[idx] = newValue
        }
    }
    // 座席数
    var numberOfSheets: Int {
        return sheets.count
    }
    // イニシャライザ
    init(numberOfSheets: Int) {
        self.sheets = Array(count: numberOfSheets, repeatedValue: false)
    }
}

/* 映画クラス */
class Movie {
    let title: String           // タイトル
    var director: String?       // 監督
    var leadingActors: String?  // 主演
    // イニシャライザ
    init(_ title: String) {
        self.title = title
    }
    // 説明
    func printDescription() {
        print(&quot;タイトル:\(title)&quot;)
        if let director = self.director {
            print(&quot; 監督:\(director)&quot;)
        }
        if let leadingActors = self.leadingActors {
            print(&quot; 主演:\(leadingActors)&quot;)
        }
        print()
    }
}
</code></pre>

<p>映画館クラスは、スクリーンの配列をオプショナル型のプロパティとして持っています。スクリーンクラスの座席は空き状況をBool型（空席ならfalse）で保持する配列で、イニシャライザで受け取った座席数の大きさの配列に初期化しています。また座席の空き状況に直接アクセスできるようにサブスクリプトを使っています。映画クラスは、タイトル、監督名、主演俳優名をプロパティに持つ単純なクラスです。</p>

<p>まず、映画館クラスのインスタンスを生成してみます。</p>

<pre><code>// 映画館
let theater = MovieTheater(&quot;りんごシアター&quot;)
</code></pre>

<p>映画館クラスのスクリーンの配列はオプショナル型ですが、オプショナルの連鎖を使って安全にアクセスできます。次は映画館クラスのスクリーン数を取得しています。</p>

<pre><code>if let numScreens = theater.screens?.count {
    print(&quot;\(theater.name)のスクリーン数は\(numScreens)です。&quot;)
} else {
    print(&quot;\(theater.name)にスクリーンは有りません。&quot;)
}
/* 実行結果
  りんごシアターにスクリーンは有りません。
*/
</code></pre>

<p>今度は映画館にスクリーンと映画を設定してみます。</p>

<pre><code>// スクリーンA
let screenA = Screen(numberOfSheets: 150)
let dieHard = Movie(&quot;ダイ・ハード&quot;)
dieHard.director = &quot;ジョン・マクティアナン&quot;
dieHard.leadingActors = &quot;ブルース・ウィリス&quot;
screenA.movie = dieHard

// スクリーンB
let screenB = Screen(numberOfSheets: 200)
let terminator = Movie(&quot;ターミネーター&quot;)
terminator.director = &quot;ジェームズ・キャメロン&quot;
terminator.leadingActors = &quot;アーノルド・シュワルツェネッガー&quot;
screenB.movie = terminator

theater.screens = [screenA, screenB]

if let numScreens = theater.screens?.count {
    print(&quot;\(theater.name)のスクリーン数は\(numScreens)です。&quot;)
} else {
    print(&quot;\(theater.name)にスクリーンは有りません。&quot;)
}
/* 実行結果
  りんごシアターのスクリーン数は2です。
*/
</code></pre>

<p>最初のスクリーンの上映映画のタイトルを表示してみます。</p>

<pre><code>if let title = theater.screens?[0].movie?.title {
    print(title)
}
/* 実行結果
   ダイハード
*/
</code></pre>

<p>スクリーンクラスの映画プロパティもオプショナル型なので、movieの後に?をつけてアクセスしています。このように、オプショナル型へのアクセスを繋いで一回でアクセスできます。
この連鎖の途中のオプショナル型がnilだった場合は、nilが返されます。また、映画クラスのタイトルはString型なので、この連鎖から返される値は、Stringのオプショナル型となります。上では、オプショナルバインディングを使って戻り値をアンラップしています。</p>

<p>これをオプショナルの連鎖を使わずに記述すると次のようになります。</p>

<pre><code>if let screens = theater.screens {
    if let movie = screens[0].movie {
        print(movie.title)
    }
}
/* 実行結果
   ダイハード
*/
</code></pre>

<p>このように、オプショナルの連鎖を使わない場合、階層の途中のオプショナル型の数が増えるほどアンラップの確認のための記述が増えます。</p>

<blockquote>
<p>本来はスクリーン配列の範囲チェックも必要ですがここでは省いています。下の座席配列も同様です。</p>
</blockquote>

<p>次は、2番目のスクリーンの、25番目のシートの空席状況を調べます。</p>

<pre><code>if let sheet = theater.screens?[1][24] {
    print(sheet ? &quot;埋まってます。&quot; : &quot;空席です。&quot;)
}
/* 実行結果
   空席です。
*/
</code></pre>

<p>空席状況はスクリーンクラスのサブスクリプトで取得できるので、2番目のスクリーン（theater.screens?[1]）で返されるスクリーンのインスタンスから25番目の空席状況を取得するために、[24]でアクセスしています。</p>

<blockquote>
<p>仮に、スクリーンクラスの座席配列の型がBool型でなく、何かの型のオプショナル型だったとしたら、次の様にサプスクリプトから取り出す[]の後に、?をつけて同じ様にアクセスできます。</p>
</blockquote>

<pre><code>theater.screens?[1][24]?.hogehoge
</code></pre>

<p>値を設定もオプショナルの連鎖を使って安全にできます。</p>

<pre><code>theater.screens?[1][24] = true
if let sheet = theater.screens?[1][24] {
    print(sheet ? &quot;埋まってます。&quot; : &quot;空席です。&quot;)
}
/* 実行結果
   埋まってます。
*/
</code></pre>

<p>もし、連鎖の途中のオプショナル型の何れかがnilであった場合、値は設定されずエラーも発生しません。</p>

<p>次は、最初のスクリーンの映画監督を出力します。</p>

<pre><code>if let director = theater.screens?[0].movie?.director {
    print(director)
}
/* 実行結果
   ジョン・マクティアナン
*/
</code></pre>

<p>映画クラスの監督プロパティは、Stringのオプショナル型ですが、その場合でもオプショナルの連鎖から返される方は、Stringのオプショナル型です。String型の場合はString型のオプショナル型が返されますが、String型のオプショナル型の場合でも同様にString型のオプショナル型が返されるということです。取得する型がオプショナル型かどうかは、オプショナルの連鎖から返される型には影響しません。</p>

<p>値の変更も同じ様にできます。</p>

<pre><code>theater.screens?[0].movie?.director = &quot;ジョン・マクティアナン（John McTiernan）&quot;
</code></pre>

<p>もし連鎖のいずれかのオプショナル型がnilのため値を変更できない場合は、nilが返されるため、次のようにして値を変更できたか確認することができます。</p>

<pre><code>if (theater.screens?[0].movie?.director = &quot;ジョン・マクティアナン（John McTiernan）&quot;) != nil {
    print(&quot;監督名を変更しました。&quot;)
}
</code></pre>

<p>インスタンスメソッドの呼び出しも同様です。</p>

<pre><code>theater.screens?[1].movie?.printDescription()
/* 実行結果
   タイトル:ターミネーター 監督:ジェームズ・キャメロン 主演:アーノルド・シュワルツェネッガー
*/
</code></pre>

<p>オプショナルの連鎖の途中がnilだった場合、メソッドは実行されません。</p>

<p>値を返さないメソッドの戻り値の型はVoidであるため、オプショナルの連鎖によるメソッド呼び出しの型はVoid?となります。次のように、戻り値をnilと比較して、メソッドが実行されたか判断することができます。</p>

<pre><code>if theater.screens?[1].movie?.printDescription() != nil {
    print(&quot;メソッドは実行されました。&quot;)
}
</code></pre>

<p>もし事前にメソッドが実行可能かどうかを確認したい場合は、次のようにメソッド自体を戻り値としてアンラップ後実行することができます。</p>

<pre><code>if let method = theater.screens?[1].movie?.printDescription {
    method()
}
/* 実行結果
   タイトル:ターミネーター 監督:ジェームズ・キャメロン 主演:アーノルド・シュワルツェネッガー
*/
</code></pre>

<p>ここで、theater.screens?[1].movie?.printDescription から返される型は、printDescriptionメソッドの型 () -&gt; () のオプショナル型ということになります。つまり、次の様に記述するのと同義です。</p>

<pre><code>let method: (() -&gt; ())? = theater.screens?[1].movie?.printDescription
if (method != nil) {
    method!()
}
</code></pre>

<h2 id="型キャスト">型キャスト</h2>

<p>型キャストとは継承ツリーの中のあるスーパークラスの変数を、そのサブクラスのインスタンスと看做せるか判定したり、変換したりする仕組みの事をいいます。</p>

<p>言語によっては、異なる型間での変換（例えば、整数と浮動小数点数等）も型キャストと呼ぶ場合がありますが、Swiftでは、基本的に同じベースクラスをスーパークラスにもつ型同士で扱われます。</p>

<p>例として、以下の様なGUIコントロールのベースクラスを継承する、ラベル、ボタン、テキストボックスを使って説明します。</p>

<pre><code>/* GUIコントロール */
class GUIControl {
    var x, y, width, height: Float  // 位置と幅、高さ
    // イニシャライザ
    init(x: Float, y: Float, width: Float, height: Float) {
        self.x = x
        self.y = y
        self.width = width
        self.height = height
    }
}

/* ラベル */
class Label: GUIControl {
    var text: String    // テキスト
    // イニシャライザ
    init(x: Float, y: Float, width: Float, height: Float, text: String = &quot;&quot;) {
        self.text = text
        super.init(x: x, y: y, width: width, height: height)
    }
}

/* ボタン */
class Button: Label {
    var _pushed = false     // 押された？
    var isPushed: Bool {
        return _pushed
    }
}

/* テキストボックス */
class TextBox: Label {
    var readOnly = false    // 入力不可？
}
</code></pre>

<p>上の各クラスのインスタンスを適当に生成して配列に格納します。</p>

<pre><code>// コントロールの配列
let controls = [
    Label(x: 10, y: 10, width: 100, height: 30, text: &quot;名前&quot;),
    TextBox(x: 120, y: 10, width: 100, height: 30),
    Label(x: 10, y: 50, width: 100, height: 30, text: &quot;住所&quot;),
    TextBox(x: 120, y: 50, width: 100, height: 30),
    Button(x: 120, y: 50, width: 100, height: 30, text:&quot;送信&quot;)
]
</code></pre>

<p>ここでは配列に格納する型を明示していませんが、全ての要素がLabelという共通のクラスを継承しているので、型は自動的に、[Label]と類推されます。</p>

<blockquote>
<p>Labelが継承しているGUIControlも共通のクラスですが、継承ツリーの中でより詳細な下位の共通クラスが類推されます。</p>
</blockquote>

<p>もし、この配列の中に共通のスーパークラスを持たないクラスのインスタンスが含まれていた場合、型は[AnyObject]となります。AnyObjectは、全てのクラスを表すことができる特別な型です。但し、明示的にAnyObjectを継承してクラスを定義することはできません。
また、配列の中に、クラスのインスタンスでない型（IntやString、構造体のインスタンス等）が含まれていた場合、型は[Any]と類推されます。Anyは、関数型を除く全ての型を表すことができる型です。</p>

<p>インスタンスが継承ツリーの中のあるサブクラスのインスタンスかどうかは、is演算子を使って判定できます。
次の例では、上で作成した配列をループしながら、それぞれのクラスのインスタンスの数を数えています。</p>

<pre><code>var labelCount = 0      // ラベル数のカウント
var buttonCount = 0     // ボタン数のカウント
var textBoxCount = 0    // テキストボックスのカウント

for control in controls {
    if control is Button {
        ++buttonCount
    } else if control is TextBox {
        ++textBoxCount
    } else {
        ++labelCount
    }
}
println(&quot;ボタン：\(buttonCount)個、テキストボックス：\(textBoxCount)個、ラベル：\(labelCount)個&quot;)
/* 実行結果
ボタン：1個、テキストボックス：2個、ラベル：2個
*/
</code></pre>

<p>上の例では、配列は[Label]と類推されているので、control is Label は必ず真となります。常に真なのでループの中でこのコードを記述しても無意味なコードということでコンパイルエラーになります。</p>

<p>あるインスタンスが、あるクラス又はそのスーパークラスのインスタンスであることが明確な場合は、as!演算子を使ってその型へ変換（ダウンキャスト）することができます。</p>

<pre><code>var control: GUIControl
control = controls[3]

let textBox = control as! TextBox
</code></pre>

<p>この時、型が合っておらずダウンキャストが失敗した場合、実行時エラーが発生します。</p>

<p>ダウンキャスト可能かどうか明確でない場合は、as?演算子を使って、オプショナル型を受け取るようにすることができます。この場合、ダウンキャストに失敗するとnilが返されます。</p>

<pre><code>var control: GUIControl
control = controls[3]

// 下のbuttonはButton?型
// ダウンキャストに失敗したらnilになる
let button = control as? Button
</code></pre>

<p>as?演算子はオプショナル型を返すので、if文でオプショナルバインディングを使うことができます。</p>

<pre><code>for control in controls {
    if let button = control as? Button {
        let isPushed = button.isPushed ? &quot;押された&quot; : &quot;押されていない&quot;
        print(&quot;ボタン:\(button.text) \(isPushed)&quot;)
    } else if let textBox = control as? TextBox {
        let readOnly = textBox.readOnly ? &quot;入力不可&quot; : &quot;入力可&quot;
        print(&quot;テキストボックス:\(textBox.text) \(readOnly)&quot;)
    } else {
        print(&quot;ラベル:\(control.text)&quot;)
    }
}
/* 実行結果
ラベル:名前
テキストボックス: 入力可
ラベル:住所
テキストボックス: 入力可
ボタン:送信 押されていない
*/
</code></pre>

<p>AnyObjectはどのクラスにも適用できるので、次のようにAnyObject型の配列にLabelクラスのインスタンスを保持することもできます。
配列の要素は全てLabel型なので、as!演算子を使って型キャストしても実行時エラーはおきません。</p>

<pre><code>let objects: [AnyObject] = [
    Label(x: 10, y: 10, width: 100, height: 30, text: &quot;名前&quot;),
    Label(x: 10, y: 50, width: 100, height: 30, text: &quot;住所&quot;),
    Label(x: 10, y: 90, width: 100, height: 30, text: &quot;電話番号&quot;),
]

for object in objects {
    let label = object as! Label
    print(&quot;ラベル:\(label.text)&quot;)
}
</code></pre>

<p>上のループは次のように、配列自体を型キャストしてもう少し簡単に記述できます。</p>

<pre><code>for label in objects as! [Label] {
    print(&quot;ラベル:\(label.text)&quot;)
}
</code></pre>

<p>Anyは、関数型を除くあらゆる型を表すことができるので、次のようにAny型の配列にさまざまな値を保持させることができます。</p>

<pre><code>let things: [Any] = [
    100,
    -23.56,
    &quot;吾輩は猫である&quot;,
    (&quot;救急車&quot;, 119),
    Label(x: 10, y: 10, width: 100, height: 30, text: &quot;名前&quot;),
    TextBox(x: 120, y: 10, width: 100, height: 30),
    Button(x: 120, y: 50, width: 100, height: 30, text: &quot;送信&quot;)
]
</code></pre>

<p>switch文の中でas演算子（as!ではありません）やis演算子を使ってこれらの型を調べることができます。</p>

<pre><code>for thing in things {
    switch thing {
    case 100 as Int:
        print(&quot;整数:100&quot;)
    case is Int:
        print(&quot;100以外の整数&quot;)
    case let d as Double where d &lt; 0:
        print(&quot;負の浮動小数点数:\(d)&quot;)
    case is Double:
        print(&quot;0以上の浮動小数点数&quot;)
    case let s as String:
        print(&quot;文字列:\(s)&quot;)
    case let (contact, tel) as (String, Int):
        print(&quot;\(contact)の電話番号:\(tel)&quot;)
    case let button as Button:
        print(&quot;ボタン:\(button.text)&quot;)
    case let c as GUIControl:
        print(&quot;ボタン以外のGUIコントロール:（x:\(c.x), y:\(c.y), width:\(c.width), height:\(c.height)）&quot;)
    default:
        print(&quot;不明な型&quot;)
    }
}

/* 実行結果
整数:100
負の浮動小数点数:-23.56
文字列:吾輩は猫である
救急車の電話番号:119
ボタン以外のGUIコントロール:（x:10.0, y:10.0, width:100.0, height:30.0）
ボタン以外のGUIコントロール:（x:120.0, y:10.0, width:100.0, height:30.0）
ボタン:送信
*/
</code></pre>

<h2 id="ネストした型">ネストした型</h2>

<p>Swiftではクラスや構造体、列挙型の定義の中に、さらにクラスや構造体、列挙型を定義することができます。つまり型をネストして定義できるということです。</p>

<p>このネストの階層には制限がありません。ネストした型のさらに内部に型を定義できます。</p>

<p>具体例を次に示します。</p>

<pre><code>// パーソンクラス
class Person {
    // 血液型
    enum BloodType: String {
        case A = &quot;A&quot;
        case B = &quot;B&quot;
        case O = &quot;O&quot;
        case AB = &quot;AB&quot;
        var asString: String {
            return self.toRaw() + &quot;型&quot;
        }
    }
    // 体格
    struct BodySize {
        // 体型
        enum Shape {
            case Normal, Fat, Thin
            var asString: String {
                switch self {
                case Normal:
                    return &quot;標準体型&quot;
                case Fat:
                    return &quot;太り気味&quot;
                case Thin:
                    return &quot;痩せ気味&quot;
                }
            }
        }
        var height: Float   // 身長
        var weight: Float   // 体重
        var bmi: Float {    // BMI ( = 体重(Kg) / (身長(m) x 身長(m)) )
            return weight / powf(height / 100.0, 2.0)
        }
        var shape: Shape {  // 体型
            switch bmi {
            case let v where v &lt; 18.5:
                return .Thin
            case let v where v &gt;= 25.0:
                return .Fat
            default:
                return .Normal
            }
        }
    }
    let name: String            // 名前
    var bloodType: BloodType    // 血液型
    var bodySize: BodySize      // 体格
    // イニシャライザ
    init(name: String, bloodType: BloodType, height: Float, weight: Float) {
        self.name = name
        self.bloodType = bloodType
        self.bodySize = BodySize(height: height, weight: weight)
    }
    // 詳細出力
    func printDescription() {
        print(&quot;名前:\(name) 血液型:\(bloodType.asString) 身長:\(bodySize.height)cm 体重:\(bodySize.weight)kg 体型:\(bodySize.shape.asString)&quot;)
    }
}

let suzuki = Person(name: &quot;鈴木花子&quot;, bloodType: .A, height: 155.0, weight: 45.0)
print(suzuki.bodySize.height)
/* 実行結果
155.0
*/

let abe = Person(name: &quot;阿部れいじ&quot;, bloodType: .A, height: 170.0, weight: 60.0)
abe.printDescription()
/* 実行結果
名前:阿部れいじ 血液型:A型 身長:170.0cm 体重:60.0kg 体型:標準体型
*/
</code></pre>

<p>この例では、パーソンクラスの定義の中に、血液型を表す列挙型と、体格用の構造体を定義しています。また、体格用の構造体の中にさらに体型を表す列挙型を定義しています。</p>

<p>体型は、身長と体重から求められるBMI（ボディマス指数：体重(Kg) ÷ 身長(m)2で算出）というものを使って、標準体型か痩せ気味か太り気味かを判定して列挙型で返しています。</p>

<p>このように、ある型に固有の属性として使用する型や、その型の定義のために一時的に使用するような型を内部で定義することで、その型特有の定義であることが明確になり、またコードのメンテナンス性も向上します。</p>

<p>ネストした型をそれが属する型の外側のスコープから使用することもできます。例えば、上のパーソンクラスの中で定義している体型の列挙型も次のようにして使うこともできます。</p>

<pre><code>let shape = Person.BodySize.Shape.Fat
print(shape.asString)
/* 実行結果
太り気味
*/
</code></pre>

<h2 id="エクステンション">エクステンション</h2>

<p>エクステンションとは拡張という意味ですが、読んで字の如く、エクステンションを使うと既存のクラスや構造体、列挙型に新たに機能を追加することができます。Objective-Cにもカテゴリーという、クラスを拡張する機能がありますがこれと似ています。</p>

<p>具体的には次のようなことができます。</p>

<ul>
<li>計算型プロパティと静的な計算型プロパティ（計算型の型プロパティ）を追加できます。</li>
<li>インスタンスメソッドと型メソッドを追加できます。</li>
<li>イニシャライザを追加できます。（追加できるのはコンビニエンスイニシャライザのみです。指定イニシャライザやデイニシャライザは追加できません。）</li>
<li>サブスクリプトを追加できます。</li>
<li>ネストした型を定義してそれを使うことができます。</li>
<li>新たなプロトコルに適合させることができます。</li>
</ul>

<blockquote>
<p>エクステンションにより既存のメソッドをオーバーライドすることはできません。</p>
</blockquote>

<p>エクステンションを使う場合は、次の様に型名の前にextensionキーワードをつけます。</p>

<pre><code>extension SomeType {
    // 新たなメソッドの追加やプロトコルへの適応
}
</code></pre>

<p>エクステンションにより新たなプロトコルへ適応させる場合は、次の様に記述します。</p>

<pre><code>extension SomeType: SomeProtocol, AnotherProtocol {
    // プロトコルへ適応するためのメソッド
}
</code></pre>

<blockquote>
<p>エクステンションを定義すると、エクステンションで追加した機能をその型の全てのインスタンスで利用できます。これは、エクステンションの定義の前に生成されたインスタンスであっても同様です。</p>

<p>エクステンションを使うと、このように既存の型に計算型プロパティを追加できます。しかし、保持型プロパティを追加したり、既存のプロパティのオブザーバーを追加することはできません。</p>
</blockquote>

<p><strong>計算型プロパティの追加</strong></p>

<p>Int型を拡張して、16進数、8進数、2進数の文字列を返すプロパティを実装してみます。</p>

<pre><code>// Int型の拡張
extension Int {
    // 16進数
    var hex: String {
        return String(self, radix: 16)
    }
    // 8進数
    var oct: String {
        return String(self, radix: 8)
    }
    // 2進数
    var bin: String {
        return String(self, radix: 2)
    }
}

print(30.hex)     // 1e
print(10.oct)     // 12
print(6.bin)      // 110
</code></pre>

<p>この様に既存の型に簡単にプロパティを追加することができます。 プロパティの中で参照しているselfは、Int型のインスタンスを指しています。</p>

<p><strong>イニシャライザの追加</strong></p>

<p>エクステンションで追加できるイニシャライザはコンビニエンスイニシャライザのみです。指定イニシャライザは追加できません。</p>

<p>次のような構造体があるとします。</p>

<pre><code>// パーソン
struct Person {
    let name: String        // 名前
    var email: String       // メールアドレス
    var age: Int            // 年齢
}

let taro = Person(name: &quot;山田太郎&quot;, email: &quot;taro@example.com&quot;, age: 35)
</code></pre>

<p>この構造体に、カンマ区切りのデータを渡して初期化するイニシャライザを、エクステンションを使って定義してみます。</p>

<pre><code>extension Person {
    init(csv: String) {
        let data = csv.componentsSeparatedByString(&quot;,&quot;)
        var name: String? = nil
        var email: String? = nil
        var age: Int? = nil
        if data.count &gt; 0 { name = data[0].stringByTrimmingCharactersInSet(NSCharacterSet(charactersInString: &quot; \&quot;&quot;)) }
        if data.count &gt; 1 { email = data[1].stringByTrimmingCharactersInSet(NSCharacterSet(charactersInString: &quot; \&quot;&quot;)) }
        if data.count &gt; 2 { age = data[2].stringByTrimmingCharactersInSet(NSCharacterSet(charactersInString: &quot; \&quot;&quot;)).toInt() }
        self.init(name: name, email: email, age: age)
    }
}

let csv: String = &quot;\&quot;山田太郎\&quot;, \&quot;taro@example.com\&quot;, 35&quot;

let taro = Person(csv: csv)
print(&quot;名前:\(taro.name!) メール:\(taro.email!) 年齢:\(taro.age!)&quot;)
/* 実行結果
名前:山田太郎 メール:taro@example.com 年齢:35
*/
</code></pre>

<p>エクステンションでイニシャライザを定義する場合もプロパティの初期化には責任を持つ必要があります。上の例では、カンマ区切りの文字列から取り出した値を引数にメンバワイズイニシャライザを呼び出してプロパティを初期化しています。</p>

<p><strong>メソッドの追加</strong></p>

<p>エクステンションを使って、インスタンスメソッドや型メソッドを追加することもできます。</p>

<p>次の例では、String型に文字列を反転するreverseメソッドを追加しています。</p>

<pre><code>extension String {
    mutating func reverse() {
        var str = &quot;&quot;
        for ch in self {
            str = String(ch) + str
        }
        self = str
    }
}

var text = &quot;Hello, Swift&quot;
text.reverse()
print(text)      // tfiwS ,olleH
</code></pre>

<p>次の例では、Int型に、受け取った関数型の処理を繰り返すメソッドを追加しています。</p>

<pre><code>extension Int {
    func times(task: () -&gt; ()) {
        for _ in 0..&lt;self {
            task()
        }
    }
}

3.times( { print(&quot;Hello, Swift&quot;) } )
/* 実行結果
Hello, Swift
Hello, Swift
Hello, Swift
*/
</code></pre>

<p><strong>サブスクリプトの追加</strong></p>

<p>既存の型にサブスクリプトを追加することもできます。</p>

<p>次の例では、String型にサブスクリプトを追加し、Int型のインデックスで指定した位置の文字を返すようにしています。</p>

<pre><code>extension String {
    subscript(index: Int) -&gt; Character {
        let idx = advance(self.startIndex, index)
        return self[idx]
    }
}

let text = &quot;吾輩は猫である。&quot;
print(text[3])    // 猫
</code></pre>

<p><strong>ネストした型の追加</strong></p>

<p>次の例では、String型に種類を表す列挙型をネストした型として定義して、その種類を返すメソッドを追加します。</p>

<pre><code>extension String {
    enum Type {
        case URL, EMail, Telephone, Other
    }
    // 文字列の種類
    var type: Type {
        var error: NSError?
        // URL
        var regex = NSRegularExpression(pattern:&quot;^(https?|ftp)(:\\/\\/[-_.!~*\\'()a-zA-Z0-9;\\/?:\\@&amp;=+\\$,%#]+)$&quot;,
            options: NSRegularExpressionOptions.CaseInsensitive,
            error: &amp;error)
        if regex.numberOfMatchesInString(self, options: nil, range: NSRange(location: 0, length: countElements(self))) &gt; 0 {
            return .URL
        }
        // メールアドレス
        regex = NSRegularExpression(pattern:&quot;^[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}$&quot;,
            options: NSRegularExpressionOptions.CaseInsensitive,
            error: &amp;error)
        if regex.numberOfMatchesInString(self, options: nil, range: NSRange(location: 0, length: countElements(self))) &gt; 0 {
            return .EMail
        }
        // 電話番号
        regex = NSRegularExpression(pattern:&quot;^\\d{1,4}-?\\d{4}$|\\d{2,5}-?\\d{1,4}-?\\d{4}$&quot;,
            options: NSRegularExpressionOptions.CaseInsensitive,
            error: &amp;error)
        if regex.numberOfMatchesInString(self, options: nil, range: NSRange(location: 0, length: countElements(self))) &gt; 0 {
            return .Telephone
        }

        return .Other
    }
}

let url = &quot;http://example.com?id=test&amp;num=123&quot;
print(url.type == .URL)           // true

let email = &quot;test@example.com&quot;
print(email.type == .EMail)       // true

let phone = &quot;03-123-9876&quot;
print(phone.type == .Telephone)   // true

let text = &quot;Hello, Swift!&quot;
print(text.type == .Other)        // true
</code></pre>

<p>正規表現を使って文字列の書式が、URLか、メールアドレスか、電話番号か、それ以外かの判定をして、メソッド内に定義した列挙型を結果として返しています。</p>

<blockquote>
<p>現時点(2014年9月)で、特にSwiftの正規表現のためのクラスや仕様は提供されていません。ここではCocoaのNSRegularExpressionを使っています。また、ここで使用しているパターンも簡易的なもので厳密なものではありません。</p>
</blockquote>

<h2 id="プロトコル">プロトコル</h2>

<p>プロトコルとはJavaやC#でいうインターフェースに似たもので、簡単に言うとクラスの挙動を決めた設計図みたいなものになります。クラス自体にも設計図という側面がありますが、クラスがその属性や挙動を細部に渡って記述するのに対して、プロトコルでは外部へのインターフェースのみを定義します。そして実際の挙動はそのプロトコルを採用するクラスで記述することになります。
クラスの利用者から見た場合、そのクラスがあるプロトコルに適合していると宣言されていれば、そのプロトコルで定義されているインターフェースを使えるということが保証されていることになります。</p>

<p>また、Swiftのプロトコルはクラスだけでなく、構造体や列挙型にも採用することもできます。</p>

<p>プロトコルの定義の仕方は、クラスや構造体の場合と似ています。</p>

<pre><code>protocol SomeProtocol {
    // インターフェースの定義
    func someMethod()
    :
}
</code></pre>

<p>ブロトコルの名前はクラスや構造体と同様、大文字で始めます。</p>

<p>プロトコルに適合させるには、型名の後に:（コロン）をつけて宣言します。次は構造体をプロトコルに適合させる場合です。</p>

<pre><code>struct SomeStructure: SomeProtocol {
    func someMethod()
    :
}
</code></pre>

<p>複数のプロトコルに適合させる場合は、プロトコルを,（カンマ）で区切って並べて記述します。</p>

<pre><code>struct SomeStructure: SomeProtocol, AnotherProtocol {
    func someMethod()
    :
}
</code></pre>

<p>また、クラスにプロトコルを適合させる場合、そのクラスがスーパークラスを持っている場合は、スーパークラス名の後にプロトコル名を書きます。</p>

<pre><code>class SomeClass: SuperClass, SomeProtocol, AnotherProtocol {
    func someMethod()
    :
}
</code></pre>

<blockquote>
<p>プロトコルへの適合を宣言した型が、そのプロトコルの要求を満たしていない場合コンパイルエラーになります。</p>
</blockquote>

<p><strong>プロパテイの要求</strong></p>

<p>プロトコルにインスタンスプロパティや型プロパティを定義できます。実装する側では保持型プロパティと計算型プロパティのどちらで実装しても構いません。
プロパティの宣言時には、getterとsetterのどちらか、或いは両方を指定します。
次の例では、プログレスバーに進捗状況を表示させるためのプロトコルを定義しています。</p>

<pre><code>// 進捗表示項目プロトコル
protocol Progressing {
    var total: Int { get }          // 総量
    var completed: Int { get set }  // 完了した量
}
</code></pre>

<p>型プロパティを定義する場合は、classをつけて定義します。これは、構造体や列挙型でプロトコルに適合させる場合でも同じです。実際に構造体で実装する場合は、staticをつけて型プロパティとして実装することになります。</p>

<pre><code>protocol Progressing {
    class var numberOfProcessing: Int { get set }// 処理項目数
    :
}
</code></pre>

<p>次の例では、構造体をProgressingプロトコルに適合させています。totalプロバティは定数になっていますが、プロトコルでgetterのみ指定されているので適合します。</p>

<pre><code>struct Music: Progressing {
    let total: Int
    var completed: Int = 0
 　　:
}

let music = Music(total: 1230, completed: 0)
</code></pre>

<p>次の例では、ダウンロード可能なファイルのクラスをProgressingプロトコルに適合させています。</p>

<pre><code>/* ダウンロード可能な音楽ファイルクラス　*/
class DownloadableFile: Progressing {
    let title: String           // タイトル
    let filePath: String        // ファイルのバス
    let fileSize: Int = 0       // ファイルサイズ
    var downloaded: Int = 0     // ダウンロード済みサイズ
    var total: Int {
        return fileSize
    }
    var completed: Int {
        get {
            return downloaded
        }
        set {
            downloaded = newValue
        }
    }
    init(title: String, filePath: String) {
        self.title = title
        self.filePath = filePath
        // ファイルからファイルサイズを取得
        let fileManager = NSFileManager.defaultManager()
        if let attr = fileManager.attributesOfItemAtPath(self.filePath, error: nil) {
            if let fileSize: AnyObject = attr[NSFileSize] {
                self.fileSize = Int((fileSize as NSInteger).value)
            }
        }
    }
    :
}

let tango = DownloadableMusic(title: &quot;黒猫のタンゴ&quot;, filePath: &quot;/var/www/contents/musics/tango.mp3&quot;)
print(tango.total)
</code></pre>

<p>ここではイニシャライザで受け取ったファイルのサイズを取得してそれを総量として使用しています。また、ダウンロードされたサイズを完了した量としています。</p>

<p><strong>メソッドの要求</strong></p>

<p>次はメソッドの定義の例をみてみます。</p>

<pre><code>protocol SomeProtocol {
    // インスタンスメソッド
    func someInstanceMethod() -&gt; String
    // 型メソッド
    class func someTypeMethod() -&gt; Int
    :
}
</code></pre>

<p>メソッド宣言の書き方は、通常のメソッドの宣言と同様ですが、{と}で囲まれた実装の部分は書きません。また、型メソッドは型プロパテイの宣言の場合と同様、classをつけて宣言します。構造体や列挙型の型メソッドの宣言ではstaticをつけますが、プロトコルはその場合でもclassをつけて宣言します。</p>

<blockquote>
<p>プロトコルのメソッドの宣言にデフォルト値を与えることはできません。可変個引数を使うことはできます。</p>
</blockquote>

<p>次の例では、テキスト形式との相互変換が可能なことを示すプロトコルを作成しています。</p>

<pre><code>protocol TextSerializable {
    // テキスト形式へ変換
    func serialize() -&gt; String
    // テキスト形式から復元
    mutating func desirialize(text: String)
}
</code></pre>

<p>テキスト形式へ変換するメソッドと、テキスト形式から復元するメソッドを宣言したプロトコルです。
復元メソッドはインスタンスの値を変更するため、mutatingを指定しています。クラスのメソッドはmutatingは不要ですが、値を変更する可能性のあるメソッドのプロトコルの宣言にはmutatingが必要です。</p>

<p>このプロトコルに構造体を適合させてみます。</p>

<pre><code>// 書籍
struct Book: TextSerializable {
    var title: String   // タイトル
    var author: String  // 著者
    // テキスト形式へ変換
    func serialize() -&gt; String {
        return &quot;タイトル:\&quot;\(title)\&quot;, 著者:\(author)&quot;
    }
    // テキスト形式から復元
    mutating func desirialize(text: String) {
        let elements = text.componentsSeparatedByCharactersInSet(NSCharacterSet(charactersInString: &quot;,&quot;))
        for element in elements {
            let e = element.componentsSeparatedByCharactersInSet(NSCharacterSet(charactersInString: &quot;:&quot;))
            if countElements(e) == 2 {
                switch e[0].stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet()) {
                case &quot;タイトル&quot;:
                    self.title = e[1]
                case &quot;著者&quot;:
                    self.author =  e[1]
                default:
                    break
                }
            }
        }
    }
}
</code></pre>

<p>ここではBook構造体の内容を、タイトル:&ldquo;〜&rdquo;, 著者:〜という形式のテキストへ変換しています。</p>

<p>Book構造体は、TextSerializableプロトコルに適合したので、TextSerializable型の変数へ代入し、メソッドを呼び出すことができます。</p>

<pre><code>var ts: TextSerializable = Book(title: &quot;坊っちゃん&quot;, author: &quot;夏目漱石&quot;)
let text = ts.serialize()
print(text)   // &quot;タイトル:&quot;坊っちゃん&quot;, 著者:夏目漱石&quot;
ts.desirialize(text)
</code></pre>

<p>次は、テキスト形式から復元したインスタンスを返す型メソッドをプロトコルに追加します。</p>

<pre><code>protocol TextSerializable {
    // テキスト形式へ変換
    func serialize() -&gt; String
    // テキスト形式から復元
    mutating func desirialize(text: String)
    // テキスト形式から復元したインスタンスを返す
    class func deserialize(text: String) -&gt; TextSerializable?
}
</code></pre>

<p>インスタンスを生成出来ない場合を考慮してオプショナル型を返すようにしています。</p>

<p>このプロトコルを今度はクラスに適合させてみます。</p>

<pre><code>// パーソンクラス
class Person: TextSerializable {
    var name: String    // 名前
    var age: Int?       // 年齢
    // イニシャライザ
    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
    // テキスト形式へ変換
    func serialize() -&gt; String {
        return &quot;名前:\&quot;\(name)\&quot;, 年齢:\(age!)&quot;
    }
    // テキスト形式から復元
    func desirialize(text: String) {
        if let p = Person.deserialize(text) as? Person {
            self.name = p.name
            self.age = p.age
        }
    }
    // テキスト形式から復元したインスタンスを返す
    class func deserialize(text: String) -&gt; TextSerializable? {
        let elements = text.componentsSeparatedByCharactersInSet(NSCharacterSet(charactersInString: &quot;,&quot;))
        var name: String?, age: Int?
        for element in elements {
            let e = element.componentsSeparatedByCharactersInSet(NSCharacterSet(charactersInString: &quot;:&quot;))
            if countElements(e) == 2 {
                switch e[0].stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet()) {
                case &quot;名前&quot;:
                    name = e[1]
                case &quot;年齢&quot;:
                    age = e[1].toInt()
                default:
                    break
                }
            }
        }
        return name == nil ? nil : Person(name: name!, age: age!)
    }
}
</code></pre>

<p>テキストへの変換方法は上の構造体の場合と同様です。クラスの場合はプロパティを変更する場合でもメソッドにmutatingをつける必要はありません。コードの重複を避けるため、インスタンスメソッドのdesirialize()内から、クラスメソッドのdesirialize()を呼び出すようにしています。</p>

<p>Book構造体とPersonクラスはどちらもTextSerializableプロトコルに適合するので、[TextSerializable]型の配列に格納することができます。</p>

<pre><code>let botchan = Book(title: &quot;坊っちゃん&quot;, author: &quot;夏目漱石&quot;)
let natume = Person(name: &quot;夏目漱石&quot;, age: 60)
let maihime = Book(title: &quot;舞姫&quot;, author: &quot;森鴎外&quot;)
let mori = Person(name: &quot;森鴎外&quot;, age: 49)

let items: [TextSerializable] = [botchan, natume, maihime, mori]
for item in items {
    print(item.serialize())
}

/* 実行結果
タイトル:&quot;坊っちゃん&quot;, 著者:夏目漱石
名前:&quot;夏目漱石&quot;, 年齢:39
タイトル:&quot;舞姫&quot;, 著者:森鴎外
名前:&quot;森鴎外&quot;, 年齢:28
*/
</code></pre>

<p><strong>デリゲーション</strong></p>

<p>デリゲーション（delegation）とは、委譲という意味で、あるクラスから処理の一部を他のクラスに任せたり、他のクラスへメッセージを送る等の目的でよく使われるデザインパターンです。CocoaやObjective-Cでもよく使われています。</p>

<p>プロトコルはこのデリゲーションでよく使われます。プロトコルで処理呼び出し方法を決めておいて、そのプロトコルに適合するクラスのインスタンスを渡すことで必要に応じてプロトコルで決めたメソッドを呼び出してもらいます。</p>

<p>次の例では、ファイルのダウンロードを行うDownloadProcessクラスと、その処理経過をこのクラスの利用者に通知するためのDownloadProcessDelegateというプロトコルを定義しています。</p>

<pre><code>/* ダウンロードプロセス */
class DownloadProcess {
    var file: DownloadableFile
    var delegate: DownloadProcessDelegate?
    init(file: DownloadableFile) {
        self.file = file
    }
    // ダウンロード処理
    func download() {
        var data: [Byte] = []
        self.openStream()
        delegate?.processDidStart(self)
        dispatch_async(dispatch_get_main_queue(), {
            var received = self.receiveData()
            while countElements(received) &gt; 0 {
                data += received
                self.delegate?.processDidReceiveData(self, data: data)
            }
            self.closeStream()
            self.delegate?.processDidEnd(self, data: data)
        })
    }
    // ネットワークストリームのオープン
    func openStream() {
        :
    }
    // データの受信
    func receiveData() -&gt; [Byte] {
        // 受信したデータを返す
        var data: [Byte]
        :
        return data
    }
    // ネットワークストリームのクローズ
    func closeStream() {
        :
    }
}

/* ダウンロードプロセスデリゲート */
protocol DownloadProcessDelegate {
    func processDidStart(process: DownloadProcess)
    func processDidReceiveData(process: DownloadProcess, data: [Byte])
    func processDidEnd(process: DownloadProcess, data: [Byte])
}
</code></pre>

<p>DonloadProcessのプロパティとしてDownloadProcessDelegateのオプショナル型を保持しています。このdelegateプロパティは設定されなくてもDownloadProcessクラス自体の処理には支障は無いのでオプショナル型にしてあります。初期値はnilになるのでイニシャライザの中で初期する必要もありません。
デリゲートメソッドの呼び出しには、オプショナルの連鎖を使っています。これにより、delegateプロバティがnilだった場合は、単にメソッドが呼び出されず、エラーにはなりません。</p>

<p>DownloadProcessDelegateの3つのメソッドが、downloadメソッドの中で呼び出されています。これにより、デリゲートへダウンロード処理の状況が通知されることになります。</p>

<p>実際の使い方は以下のようになります。</p>

<pre><code>/* ダウンロードマネージャ */
class DownloadManager: DownloadProcessDelegate {
    var files: [DownloadableFile] = []  // ダウンロードするファイルの配列
    var downloadedSize: Int = 0         // ダウンロード済みサイズ

    // ファイルのダウンロード
    func downloadFiles() {
        downloadedSize = 0
        for file in files {
            let process = DownloadProcess(file: file)
            process.delegate = self
            process.download()
        }
    }

    // DownloadProcessからの通知
    func processDidStart(process: DownloadProcess) {
        print(&quot;\(process.file.name)のダウンロード開始&quot;)
    }
    func processDidReceiveData(process: DownloadProcess, data: [Byte]) {
        let size = countElements(data)
        downloadedSize += size
        print(&quot;\(process.file.name)のダウンロード中...\(size)バイト&quot;)
    }
    func processDidEnd(process: DownloadProcess, data: [Byte]) {
        print(&quot;\(process.file.name)のダウンロード終了&quot;)
    }
}


let manager = DownloadManager()
manager.files += [DownloadableFile(name: &quot;黒猫のタンゴ&quot;, filePath: &quot;/var/www/contents/musics/tango.mp3&quot;),
                  DownloadableFile(name: &quot;猫踏んじゃった&quot;, filePath: &quot;/var/www/contents/musics/nekofunda.mp3&quot;),
                  DownloadableFile(name: &quot;犬のおまわりさん&quot;, filePath: &quot;/var/www/contents/musics/inu.mp3&quot;)]
manager.downloadFiles()
/*
黒猫のタンゴのダウンロード開始
猫踏んじゃったのダウンロード開始
犬のおまわりさんのダウンロード開始
黒猫のタンゴのダウンロード中...1024バイト
猫踏んじゃったのダウンロード中...1024バイト
犬のおまわりさんのダウンロード中...1024バイト
:
黒猫のタンゴのダウンロード終了
猫踏んじゃったのダウンロード終了
犬のおまわりさんのダウンロード終了
*/
</code></pre>

<p>DownloadManagerクラスをDownloadProcessDelegateプロトコルに適合させ、downloadFilesメソッドの中で生成しているDownloadProcessのインスタンスのdelegateプロパティにselfを渡しています。
そして、downloadFilesメソッドを呼び出してfilesプロパティに保持しているDownloadableFile型のdownloadメソッドを呼び出しています。処理状況に応じて各デリケートメソッドが呼び出されるので、それぞれに応じて処理します。
ここでは通知された内容をprint()で出力し、ダウンロード済みサイズをプロパティに保持しています。</p>

<p><strong>エクステンションによるプロトコルへの適合</strong></p>

<p>エクステンションを使うことで、既存の型をプロトコルへ適合させることができます。これはソースが無くライブラリとして提供されている型であっても可能です。</p>

<p>上のDownloadManagerクラスを、エクステンションを使って、同じく上で出てきたProgressingプロトコルに適合させてみます。</p>

<pre><code>extension DownloadManager: Progressing {
    // ダウンロード対象の総サイズ
    var total: Int {
        var amount = 0
            for file in self.files {
                amount += file.amount
            }
            return amount
    }
   // ダウンロード済みサイズ
    var completed: Int {
        get {
            return self.downloadedSize
        }
        set {
            self.downloadedSize = newValue
        }
    }
}
</code></pre>

<p>エクステンションでプロトコルに適合させる場合は、型名の後に、:「コロン」をつけてプロトコル名を記述します。
そして、プロトコルに適合させるためにメソッドを記述します。ここでは、Progressingプロトコルの要件である2つのメソッドを実装しています。
totalプロバティではダウンロードするファイルの総サイズを返す様にし、completedプロパティではデリゲートによる通知で集計したダウンロード済みサイズ（self.downloadedSizeの値）を返しています。</p>

<blockquote>
<p>エクステンションで保持型プロパティを追加することはできません。既存の型をエクステンションでブロトコルに適合させられるかどうかは、その型で公開されているプロパティやメソッドに依存することになります。</p>
</blockquote>

<p>既存の型が既にプロトコルへの適合条件であるプロバティーやメソッドを実装済みである場合、空のエクステンションを宣言するだけで、プロトコルへ適合させることができます。</p>

<pre><code>/* タスク構造体 */
struct Task {
    let name: String    // タスク名
    let amount: Int     // タスク量
    var completed: Int  // 完了済み料
    mutating func done(amount: Int = 1) {
        completed += amount
    }
}


extension Task: Progressing {}

var progressing: Progressing = Task(name: &quot;大掃除&quot;, amount: 100, completed: 0)
</code></pre>

<p><strong>プロトコルの継承</strong></p>

<p>クラスの継承と同様、プロトコルも継承することができます。クラスの継承と異なり、プロトコルは複数のプロトコルを継承することができます。その場合、その複数のプロトコルが要求するプロパティやメソッドを全て引き継ぐことになります。</p>

<p>プロトコルを継承する場合は次の様にプロトコル名の後に、:「コロン」を書きその後に、継承するプロトコル名書きます。複数のプロトコルを継承する場合は、それらのプロトコルを,（カンマ）で区切って記述します。</p>

<pre><code>protocol InheritingProtocol: SomeProtocol, AnotherProtocol {
  :
}
</code></pre>

<p>プロトコルの継承の例をみてみます。次の例では、上で出てきたTextSerializableプロトコルを継承して、HTMLTranslatableというプロトコルを作成しています。</p>

<pre><code>/* HTMLテキストへ変換可能なことを示すプロトコル */
protocol HTMLTranslatable: TextSerializable {
    var asHTMLText: String { get }
}

/* パーソン構造体 */
struct Person: HTMLTranslatable {
    var name: String
    var age: Int
    func serialize() -&gt; String {
        :
    }
    mutating func desirialize(text: String) {
        :
    }
    var asHTMLText: String {
        return &quot;&lt;span class=\&quot;person-name-title\&quot;&gt;名前:&lt;/span&gt;&lt;span class=\&quot;person-name\&quot;&gt;\(name)&lt;/span&gt;&quot; +
            &quot;&lt;span class=\&quot;person-age-title\&quot;&gt;年齢:&lt;/span&gt;&lt;span class=\&quot;person-age\&quot;&gt;\(age)歳&lt;/span&gt;&quot;
    }
}

let person: HTMLTranslatable = Person(name: &quot;松井イチロー&quot;, age: 41)
print(person.asHTMLText)
/* 実行結果
&lt;span class=&quot;person-name-title&quot;&gt;名前:&lt;/span&gt;&lt;span class=&quot;person-name&quot;&gt;松井イチロー&lt;/span&gt;&lt;span class=&quot;person-age-title&quot;&gt;年齢:&lt;/span&gt;&lt;span class=&quot;person-age&quot;&gt;41歳&lt;/span&gt;
*/
</code></pre>

<p><strong>プロトコルの合成</strong></p>

<p>複数のプロトコルに適合する型を示す場合は、次の様な形式で表現できます。</p>

<pre><code>protocol&lt;SomeProtocol, AnotherProtocol&gt;
</code></pre>

<p>次の例では、HTMLTranslatableとJSONSerializableという２つのプロトコルと、これらに適合する型を引数にとる関数を示しています。</p>

<pre><code>/* HTMLテキストへ変換可能なことを示すプロトコル */
protocol HTMLTranslatable: TextSerializable {
    var asHTMLText: String { get }
}

/* JSON形式に相互変換可能なことを示すプロトコル */
protocol JSONSerializable {
    func toJSON() -&gt; String     // JSON形式に変換
    mutating func fromJSON()    // JSON形式から復元
}

/* HTMLTranslatableとJSONSerializableに適合する型を引数にとる関数 */
func printAsHTMLAndJSON(printTarget: &lt;HTMLTranslatable, JSONSerializable&gt;) {
    print(&quot;HTML形式:\(printTarget.asHTMLText)\nJSON形式:\(printTarget.toJSON())&quot;)
}
</code></pre>

<p>Person構造体をこの2つのプロトコルに適合させて、printAsHTMLAndJSON関数を呼び出してみます。</p>

<pre><code>/* パーソン構造体 */
truct Person: HTMLTranslatable, JSONSerializable {
    var name: String
    var age: Int
    func serialize() -&gt; String {
      :
    }
    mutating func desirialize(text: String) {
      :
    }
    var asHTMLText: String {
        return &quot;&lt;span class=\&quot;person-name-title\&quot;&gt;名前:&lt;/span&gt;&lt;span class=\&quot;person-name\&quot;&gt;\(name)&lt;/span&gt;&quot; +
            &quot;&lt;span class=\&quot;person-age-title\&quot;&gt;年齢:&lt;/span&gt;&lt;span class=\&quot;person-age\&quot;&gt;\(age)歳&lt;/span&gt;&quot;
    }
    func toJSON() -&gt; String {
        return &quot;{\&quot;name\&quot;: \&quot;\(name)\&quot;, \&quot;age\&quot;: \(age)}&quot;
    }
    mutating func fromJSON() {
      :
    }
}

let person = Person(name: &quot;松井イチロー&quot;, age: 41)
printAsHTMLAndJSON(person)
/* 実行結果
HTML形式:&lt;span class=&quot;person-name-title&quot;&gt;名前:&lt;/span&gt;&lt;span class=&quot;person-name&quot;&gt;松井イチロー&lt;/span&gt;&lt;span class=&quot;person-age-title&quot;&gt;年齢:&lt;/span&gt;&lt;span class=&quot;person-age&quot;&gt;41歳&lt;/span&gt;
JSON形式:{&quot;name&quot;: &quot;松井イチロー&quot;, &quot;age&quot;: 41}
*/
</code></pre>

<p><strong>プロトコル適合の確認</strong></p>

<p>あるインスタンスがプロトコルに適合しているかどうか確認したり、より具体的なプロトコルへ変換するには、型キャストで使用するis演算子やas演算子を使う事ができます。</p>

<ul>
<li>あるインスタンスがis演算子で指定したプロトコルに適合していればtrue, 適合していなければfalseが返されます。</li>
<li>as?演算子を使って、あるプロトコルにダウンキャストするとそのプロトコルのオプショナル型が返されます。失敗した場合は値がnilになります。</li>
<li>as演算子を使ってダウンキャストに失敗すると、実行時エラーが発生します。</li>
</ul>

<p>プロトコルで型キャストを使用するには、次の様にプロトコルに@objcをつけて宣言する必要があります。</p>

<pre><code>// 進捗表示項目プロトコル
@objc protocol Progressing {
    var total: Int { get }          // 総量
    var completed: Int { get set }  // 完了した量
}
</code></pre>

<blockquote>
<p>@objcは、Objective-Cとの互換性を示すための特殊なマークですが、@objcをつけて宣言したプロトコルはクラスでしか使えなくなります。構造体や列挙型をこのプロトコルに適合させることはできません。</p>
</blockquote>

<p>以下に例を示します。</p>

<pre><code>// 進捗表示項目プロトコル
@objc protocol Progressing {
    var total: Int { get }          // 総量
    var completed: Int { get set }  // 完了した量
}

// 音楽クラス
class Music: Progressing {
    let title: String           // タイトル
    let total: Int              // 総サイズ
    var completed: Int = 0      // 再生済みサイズ
    init(title: String, total: Int) {
        self.title = title
        self.total = total
    }
}

let music: AnyObject = Music(title: &quot;黒猫のタンゴ&quot;, total: 23846)

if music is Progressing {
    print((music as Progressing).total)   // 23846
}

if let total = (music as? Progressing)?.total {
    print(total)      // 23846
}
</code></pre>

<p><strong>プロトコルの任意要求</strong></p>

<p>プロトコルに適合する側で必ずしも実装する必要のないプロパティやメソッドを指定することができます。次のようにプロパティやメソッドの宣言の前に、optionalをつけて宣言します。</p>

<pre><code>/* 翻訳プロトコル　*/
@objc protocol Translator {
    optional var defaultLanguage: String { get set }    // デフォルト言語
    optional func toEnglish(text: String) -&gt; String     // 英語へ翻訳
    optional func toFrench(text: String) -&gt; String      // フランス語へ翻訳
    optional func toGerman(text: String) -&gt; String      // ドイツ語へ翻訳
    :
}
</code></pre>

<p>optionalのつけられたプロパティやメソッドが実装されているかどうかは、オプショナルの連鎖で使用する構文を使って確認できます。</p>

<pre><code>class MyTranslator: Translator {
    var defaultLanguage: String
    func toEnglish(text: String) -&gt; String {
        :
        if text == &quot;こんにちは&quot; { return &quot;Hello&quot; }
        :
    }
    init(defaultLanguage: String) {
        self.defaultLanguage = defaultLanguage
    }
}

var translator: Translator?

translator = MyTranslator(defaultLanguage: &quot;Japanese&quot;)
if let lang = translator?.defaultLanguage? {
    if lang == &quot;Japanese&quot; {
        if let translated = translator?.toEnglish?(&quot;こんにちは&quot;) {
            print(translated)     // Hello
        }
    }
}
</code></pre>

<p>translatorプロトコルのdefaultLanguageはString型ですが、プロトコルの定義でoptionalが指定されているため、実装されているかどうかをオプショナルの連鎖による構文で確認でき、返される値はStringのオプショナル型となります。</p>

<p>同じく、toEnglishメソッドにもoptionalが指定されているため、オプショナルの連鎖を使って確認ができます。メソッドの戻り値はString型ですが、ここではStringのオプショナル型が返されます。オプショナルバインディングを使ってアンラップされた値を取り出すことができます。(値がnilでない場合)</p>

<h2 id="ジェネリクス">ジェネリクス</h2>

<p>ジェネリクスは、Swiftの最も強力な特徴の１つです。ジェネリクスを使うと、あらゆる型に対して柔軟で再利用可能な処理や型を記述することができます。
Swift自体でもジェネリクスは多用されており、例えば配列やディクショナリが型に依存せず同じように値を格納したり取り出したりできるのも、ジェネリクスを使って実装されているからです。</p>

<p><strong>ジェネリクス関数</strong></p>

<p>ここでは例として、Int型の値の大きい方を返す関数を考えてみます。</p>

<pre><code>// Int型の大きい方を返す
func bigger(val1: Int, val2: Int) -&gt; Int {
    return val1 &gt; val2 ? val1 : val2
}

println(bigger(10, 20))     // 20
</code></pre>

<p>この関数は、Int型の引数に対して大きい方の値を返しますが、Float型やDouble型の引数を渡す様にするとコンパイルエラーになります。</p>

<pre><code>var val1: Float = 10.0
var val2: Float = 20.0

println(bigger(val1, val2)) // エラー
</code></pre>

<p>次の様にFloat型やDouble型用にbigger関数のオーバーロードバージョンを作成する方法もありますが、</p>

<pre><code>// Float型の大きい方を返す
func bigger(val1: Float, val2: Float) -&gt; Float {
    return val1 &gt; val2 ? val1 : val2
}

// Double型の大きい方を返す
func bigger(val1: Double, val2: Double) -&gt; Double {
    return val1 &gt; val2 ? val1 : val2
}
</code></pre>

<p>ジェネリックスを使うと1回の記述であらゆる型に対応することができます。</p>

<pre><code>func bigger&lt;T&gt;(val1: T, val2: T) -&gt; T {
    return val1 &gt; val2 ? val1 : val2
}
</code></pre>

<p>関数名の後に、&lt;と&gt;で囲って、型を示すTという名前を指定しています。この名前はTでなくても分かり易い名前で構いませんが、慣例としてTが使われることが多いです。また、他の名前をつける場合でも大文字で始まり単語の区切りを大文字にするCamelCase（キャメルケース）にすることが推奨されています。</p>

<p>上の例では型につけた名前（T）を引数の型として使用しています。また、この関数の場合は戻り値として同じ型を返すので、戻り値にもTを使っています。</p>

<p>この様にすると、Int型だけでなく、Float型や、Double型に対しても、同じロジックを共用することができますが、残念ながらこの場合、コンパイルエラーになります。何故なら、関数の中で値の比較をしていますが、全ての型で値の比較ができるとは限らないからです。例えば、独自に定義したクラスや構造体は、大小比較用のオペーレータ関数を定義しない限り、値の比較はできません。そのため、ジェネリクスで使用する型に、比較が可能なことを明示する必要があります。</p>

<p>比較が可能なことを示すためには、そのためのプロトコルやスーパークラスを定義して、型に指定してやれば良いです。Swiftには値の比較が可能なことを示すプロトコルとして、Comparableというものが予め定義されているので、これを使うことができます。</p>

<pre><code>func bigger&lt;T: Comparable&gt;(val1: T, val2: T) -&gt; T {
    return val1 &gt; val2 ? val1 : val2
}
</code></pre>

<p>関数名の後に指定している型名に:（コロン）をつけてComparableプロトコルを指定しています。このように型名にプロトコルやスーパークラスを指定して、その型がある条件に準拠していることを示すことができます。</p>

<p>これでコンパイルエラーもなくなり、Comparableプロトコルに適合する全ての型で同じロジックを使うことができるようになりました。Int型、Float型、Double型は全てComparableプロトコルに適合しています。</p>

<pre><code>var i1 = 10
var i2 = 20
print(bigger(i1, i2)) // 20

var f1: Float = 10.0
var f2: Float = 20.0
print(bigger(f1, f2)) // 20.0

var d1: Double = 10.0
var d2: Double = 20.0
print(bigger(f1, f2)) // 20.0
</code></pre>

<p>ちなみに、String型もComparableプロトコルに適合しているので、String型の引数でも動作します。</p>

<pre><code>var s1: String = &quot;Mickey&quot;
var s2: String = &quot;Minnie&quot;
print(bigger(s1, s2)) // Minnie
</code></pre>

<blockquote>
<p>Swiftには大きい方の値を返すジェネリクス関数としてmaxという関数が既に定義されています。このmaxは複数個の引数にも対応しています。</p>
</blockquote>

<pre><code>print(max(30, 50, 20, 10, 60, 40))    // 60
</code></pre>

<p>また、小さい方の値を返す関数としてminも定義されています。</p>

<pre><code>print(min(30, 50, 20, 10, 60, 40))    // 10
</code></pre>

<p><strong>ジェネリクス型</strong></p>

<p>次はジェネリクスを使った型についてみていきます。</p>

<p>まず、ジェネリクスを使わずに、Setという名前の、値の重複を許可しない配列を定義してみます。ここではString型のみに対応した構造体にします。</p>

<pre><code>// 重複要素を許可しない配列
struct Set {
    var items = [String]()
    // 要素数
    var count: Int {
        return items.count
    }
    // 要素の追加
    mutating func append(item: String) {
        if !self.contains(item) {
            items.append(item)
        }
    }
    // 要素の削除
    mutating func remove(item: String) {
        if let idx = find(items, item) {
            items.removeAtIndex(idx)
        }
    }
    // 要素の存在確認
    func contains(item: String) -&gt; Bool {
        return Swift.contains(items, item)
    }
}

var party = Set()
party.append(&quot;ルフィ&quot;)
party.append(&quot;ゾロ&quot;)
party.append(&quot;ナミ&quot;)
party.append(&quot;ゾロ&quot;)    // 2回目×
print(party.count)   // 3
</code></pre>

<p>このSet構造体もジェネリクスを使ってあらゆる型に対応させることができます。</p>

<pre><code>// 重複要素を許可しない配列
struct Set&lt;T: Equatable&gt; {
    var items = [T]()
    // 要素数
    var count: Int {
        return items.count
    }
    // 要素の追加
    mutating func append(item: T) {
        if !self.contains(item) {
            items.append(item)
        }
    }
    // 要素の削除
    mutating func remove(item: T) {
        if let idx = find(items, item) {
            items.removeAtIndex(idx)
        }
    }
    // 要素の存在確認
    func contains(item: T) -&gt; Bool {
        return Swift.contains(items, item)
    }
}

var party = Set&lt;String&gt;()
party.append(&quot;ルフィ&quot;)
party.append(&quot;ゾロ&quot;)
party.append(&quot;ナミ&quot;)

var numbers = Set&lt;Int&gt;()
numbers.append(10)
numbers.append(20)
print(numbers.contains(10))   // true
</code></pre>

<p>型でジェネリクスを使う場合は、上の様に型名の後に、&lt;と&gt;で囲んで実装時に使用する仮の型名を指定します。型名の付け方や、プロトコル、スーパークラスによる条件の指定など、ジェネリクス関数と同様の書き方になります。</p>

<p>Set構造体のremoveメソッドで使用しているfind関数と、containsメソッドで使用しているグローバル関数のcontains関数は、共にEqutableプロトコルに適合する値を引数として要求するので、Set構造体で扱う型の条件として、Equatableプロトコルに適合することを指定しています。Equatableプロトコルは、==演算子を実装している（つまり、2つの値が同じかどうかを評価できる）ことを要求するプロトコルです。</p>

<p><strong>関連型</strong></p>

<p>上でみた様にジェネリクスを使う場合に型に対してプロトコルやスーパークラスを指定することで型に条件をつけることができます。</p>

<p>任意の型を扱うプロトコルを定義する場合に、その型を参照できると便利です。その様な場合は関連型（Associated Types）を使うことができます。</p>

<p>ここでは2つのインデックスを使って2次元の配列に任意の型を格納できるボードケーム用のプロトコルを考えてみます。</p>

<pre><code>/* ゲームボードプロトコル */
protocol GameBoard {
    typealias GamePiece             // ゲームの駒
    class var rows: Int { get }     // ボードの行数
    class var columns: Int { get }  // ボードの列数
    // ボードへの駒の設定/取得用サブスクリプト
    subscript(row: Int, column: Int) -&gt; GamePiece? { get set }
}
</code></pre>

<p>typealiasは、タイプエイリアスで説明した様に既存の型の別名を定義する時に使うものですが、この様にプロトコル定義の中で具体的な型を明示せずに宣言することで関連型として使うことができます。</p>

<p>関連型は、プロトコルで宣言したプロバティや、メソッドの引数、戻り値として参照することができます。ここでは、サブスクリプトで使用する型として参照しています。
具体的な型はプロトコルに適合させる側で指定します。次の例ではGameBoardプロトコルに適合したオセロゲーム用のボード構造体を定義しています。</p>

<pre><code>/* オセロゲームのボード */
struct OthelloBoard: GameBoard {
    // オセロの駒
    enum OthelloPiece {
        case Black, White
    }
    static var rows: Int { return 8 }     // ボードの行数
    static var columns: Int { return 8 }  // ボードの列数
    // オセロの駒をゲームの駒として再定義
    typealias GamePiece = OthelloPiece
    // マス目を表す配列
    var board = [OthelloPiece?](count: 8 * 8, repeatedValue: nil)
    // ボードへの駒の設定/取得用サブスクリプト
    subscript(row: Int, column: Int) -&gt; OthelloPiece? {
        get {
            return board[row * 8 + column]
        }
        set {
            board[row * 8 + column] = newValue
        }
    }
}

var board = OthelloBoard()
board[3, 3] = .Black
board[3, 4] = .White
</code></pre>

<p>この構造体では、オセロの駒としてネストした列挙型で定義し、GamePieceとして再定義しています。サプスクリプトも定義しプロトコルの要件を満たしています。但し、上のtypealiasによる再定義は、無くても実装されているメソッドからSwiftが推論してくれます。</p>

<p>上の場合は、オセロの駒を列挙型を使って定義していますが、次の様に簡便にBool型を使っても問題有りません。</p>

<pre><code>/* オセロゲームのボード
   オセロの駒としてBool型を使用
*/
struct OthelloBoard: GameBoard {
    static var rows: Int { return 8 }     // ボードの行数
    static var columns: Int { return 8 }  // ボードの列数
    // マス目を表す配列
    var board = [Bool?](count: 8 * 8, repeatedValue: nil)
    // ボードへの駒の設定/取得用サブスクリプト
    subscript(row: Int, column: Int) -&gt; Bool? {
        get {
            return board[row * 8 + column]
        }
        set {
            board[row * 8 + column] = newValue
        }
    }
}

var board = OthelloBoard()
board[3, 3] = true
board[3, 4] = false
</code></pre>

<p>この場合も、GamePieceはBool型であるということをSwiftが推論してくれるので、typealiasによる再定義は省略しています。</p>

<p>そしてジェネリクスを使うと、駒の型を自由に決められるようになります。</p>

<pre><code>/* オセロゲームのボード
   オセロの駒の型をジェネリクスにより汎用的にしたバージョン
*/
struct OthelloBoard&lt;T&gt;: GameBoard {
    static var rows: Int { return 8 }     // ボードの行数
    static var columns: Int { return 8 }  // ボードの列数
    // マス目を表す配列
    var board = [T?](count: 8 * 8, repeatedValue: nil)
    // ボードへの駒の設定/取得用サブスクリプト
    subscript(row: Int, column: Int) -&gt; T? {
        get {
            return board[row * 8 + column]
        }
        set {
            board[row * 8 + column] = newValue
        }
    }
}

var board = OthelloBoard&lt;String&gt;()
board[3, 3] = &quot;黒&quot;
board[3, 4] = &quot;白&quot;
</code></pre>

<p><strong>where節</strong></p>

<p>ジェネリクスの型にプロトコルやスーパークラスを指定することに加えて、whereを使ったより細かい条件の指定ができます。</p>

<p>２つのゲームボードの駒の配置が同じかどうかを検証する場合、次の様に記述できます。</p>

<pre><code>// ２つのゲームボードが同じ駒の配置か調べる関数
func isSameBoard&lt;B1: GameBoard, B2: GameBoard
  where B1.GamePiece == B2.GamePiece, B1.GamePiece: Equatable&gt;
    (someBoard: B1, anotherBoard: B2) -&gt; Bool {
        if (someBoard.dynamicType.rows != anotherBoard.dynamicType.rows) ||
            (someBoard.dynamicType.columns != anotherBoard.dynamicType.columns) {
                return false
        }
        for var row = 0; row &lt; someBoard.dynamicType.rows; row++ {
            for var col = 0; col &lt; someBoard.dynamicType.columns; col++ {
                if someBoard[row, col] != anotherBoard[row, col] {
                    return false
                }
            }
        }
        return true
}

var boardA = OthelloBoard&lt;Bool&gt;()
boardA[3, 3] = true; boardA[3, 4] = false; boardA[4, 3] = false; boardA[4, 4] = true;

var boardB = OthelloBoard&lt;Bool&gt;()
boardB[3, 3] = true; boardB[3, 4] = false; boardB[4, 3] = false; boardB[4, 4] = true;

print(isSameBoard(boardA, boardB))    // true
</code></pre>

<p>この関数では、ジェネリクスによる型の条件をwhereを使って次の様に指定しています。</p>

<ol>
<li>引数の２つの型に対して、GameBoardプロトコルの関連型であるGamePieceが同じ型であること。</li>
<li>最初の引数のGameBoardのGamePieceがEquatableプロトコルに適合すること。（1.の条件により、必然的に2番目の引数のGameBoardのGamePieceもEquatableプロトコルに適合することになります。）</li>
</ol>

<p>この指定により、２つのGmaeBoardのGamePieceがどんな型であれ、関数の実装の中で=演算子や!=演算子を使って比較できることが保証されます。</p>

<p>上の例では、まず２つのボードの行と列が同じ数かどうか調べて、同じだった場合、全てのマス目の駒の値が等しいか調べています。行と列が同じで駒も全て同じだった場合にtrueを返し、それ以外はfalseを返しています。</p>

<h2 id="アクセスコントロール">アクセスコントロール</h2>

<p>アクセスコントロールとは、プロパティやメソッドへのアクセスに制限を設けることです。この機能によりオブジェクト指向のカプセル化レベルをより細かく制御することができます。</p>

<p>Swiftのアクセスコントロールは他のオブジェクト指向言語と少し違っているところもあります。プロパティやメソッド、イニシャライザ、サブスクリプトにアクセスレベルを設定できる他、それらが属するクラス、構造体、列挙型自体にも設定できます。アクセス制限はそれらのクラスや構造体の単位ではなく、それらが記述されたソースファイルレベルで設定されます。</p>

<p>設定できるアクセスレベルは次の3つです。</p>

<p><strong>public</strong>
最も緩いアクセスレベルです。自身が属するモジュールのソースファイルからだけでなく、別のモジュールのソースファイルからもアクセスできることを許可します。フレームワークのAPIを定義する場合等に使用します。</p>

<p><strong>internal</strong>
自身が属するモジュールと同じモジュールのソースファイルからのみアクセス可能です。アプリやフレームワークを作成する際に内部構造を定義する場合等に使用します。internalはデフォルトのアクセスレベルです。明示的にアクセスレベルを指定しない場合はinternalと看做されます。そのため一般的な用途ではアクセスレベルを気にせずに記述することも可能です。</p>

<p><strong>private</strong>
最も厳しいアクセスレベルです。同じソースファイルからしかアクセスできません。モジュールの使用者から内部構造を隠蔽したい場合等に使用します。</p>

<blockquote>
<p>モジュールとはアプリやフレームワークの配布の単位で、Swiftのimportを使って別のモジュールに取り込むことができるまとまりを表します。
Xcodeでアプリやフレームワークといったビルドターゲットを作成しますが、これらがそれぞれ独立した１つのモジュールということになります。
そして、それらのモジュールを構成するためにソースファイルを記述することになります。一般的に１つの型の定義は１つのソースファイルに記述しますが、１つのソースファイルに複数の型を定義することもできます。その場合、アクセスレベルにprivateが指定してあっても同じソースコード内の別の型からアクセスできることになります。</p>

<p>他のモジュールへの機能公開を目的としない場合は、アクセスレベルを設定せずに開発することも可能です。デフォルトのアクセスレベルであるinternalが自動的に付与されるのでほとんどの用途でアクセスレベルを意識することなく開発できます。もちろん、同じモジュールの他のソースコードからのアクセスを禁止するためにprivateを設定しても構いません。</p>
</blockquote>

<p><strong>アクセスレベルの基本原則</strong></p>

<p>Swiftのアクセスレベルには、既に設定されているアクセスレベルをより厳しくするアクセスレベルへ設定できないという原則があります。例えば、</p>

<ul>
<li>publicな変数をinternal又はprivateなアクセスレベルを持つ様に再定義することはできません。</li>
<li>関数のアクセスレベルを、その関数の引数や戻り値に設定されているアクセスレベルより厳しいアクセスレベルにすることはできません。</li>
</ul>

<p><strong>アクセスコントロールの書式</strong></p>

<p>型やインスタンスにアクセスレベルを設定する場合は、それらの定義の前に、public, internal, privateの何れかの修飾子を記述します。</p>

<pre><code>public class SomePublicClass {}
internal class SomeInternalClass {}
private class SomePrivateClass {}

public var somePublicVariable = 0
internal let someInternalConstant = 0
private func somePrivateFunction() {}
</code></pre>

<p>アクセスレベルを明示しない場合は、internalがデフォルトのアクセスレベルになるので、上のSomeInternalClassとsomeInternalConstantは次のように、アクセスレベルを指定しなくても同じになります。</p>

<pre><code>class SomeInternalClass {}
let someInternalConstant = 0
</code></pre>

<p><strong>独自の型</strong></p>

<p>独自の型を定義する時にアクセスレベルを指定することができますが、例えばその型にprivateを指定した場合、その型は同じソースコード内でしか使用することができないということになります。</p>

<p>型に対して設定されたアクセスレベルは、その型のプロパティやメソッド、イニシャライザ、サブスクリプトのデフォルトのアクセスレベルに影響します。例えば、型のアクセスレベルをprivateにした場合、その型のプロパティやメソッドのデフォルトのアクセスレベルもprivateになります。また、型のアクセスレベルをinternalやpublicにした場合、その型のメンバのデフォルトのアクセスレベルはinternalになります。（型のアクセスレベルがpublicでもメンバのデフォルトはpublicではなく、internalです。）</p>

<blockquote>
<p>型のアクセスレベルがpublicでもメンバのデフォルトはpublicではなく、internalです。メンバのアクセスレベルをpublicにしたい場合は、それらに明示的に指定する必要があります。
これにより、不用意に他のモジュールへ内部実装を公開することを防ぐことができます。</p>
</blockquote>

<p><strong>タプル型</strong></p>

<p>タプルのアクセスレベルは、その構成要素のアクセスレベルの中で最も厳しいアクセスレベルになります。</p>

<pre><code>private let s = &quot;Hello!&quot;
public let i = 100

let t = (s, i)  // tのアクセスレベルはprivate
</code></pre>

<p><strong>関数型</strong></p>

<p>関数のアクセルレベルは、その関数の引数や戻り値の中で最も厳しいアクセスレベルになります。</p>

<p>publicなクラスと、privateなクラスのタプルを返す関数があった場合、その関数は、privateな関数となります。</p>

<pre><code>public class SomePublicClass {
    :
}

private class SomePrivateClass {
    :
}

private func someFunction() -&gt; (SomePublicClass, SomePrivateClass) {
    let p = SomePublicClass()
    let r = SomePrivateClass()
    :
    return (p, r)
}
</code></pre>

<p>関数からの戻り値であるタプル型のアクセスレベルがprivateになるため、関数のアクセスレベルもprivateになります。そしてこの場合。関数名の前にprivateが必要です。privateをつけて宣言しないとエラーになります。また、publicやinternalをつけて宣言した場合もエラーになります。</p>

<p><strong>列挙型</strong></p>

<p>列挙型の各caseの値のアクセスレベルは、列挙型自体のアクセスレベルと同じになります。個々のcaseの値にアクセスレベルを指定することは出来ません。</p>

<p>信号機を表す次の列挙型はpublicが指定されているため、個々の値のアクセスレベルも全てpublicになります。</p>

<pre><code>// 信号機
public enum Signal {
    case Blue       // 青
    case Yellow     // 黄   
    case Red        // 赤
}
</code></pre>

<p>列挙型に明示的に型を指定する場合、その型のアクセスレベルは、列挙型自体のアクセスレベル以上である必要があれます。例えば、internalな列挙型の値としてprivateなアクセスレベルの型を指定することはできません。</p>

<p><strong>ネストした型</strong></p>

<p>privateな型の内部で定義されたネストした型のアクセスレベルはprivateになります。また、public若しくはinternalな型の内部で定義されたネストした型のアクセスレベルはinternalになります。
もし、publicな型の内部で定義したネストした型のアクセスレベルをpublicにしたい場合は、明示的にpublicを指定する必要があります。</p>

<pre><code>public class somePublicClass {
    public class someNestedClass {
        :
    }
}
</code></pre>

<p><strong>クラスの継承</strong></p>

<p>あるクラスを継承してサブクラスを作成する場合、スーパークラスのアクセスレベルより緩いアクセスレベルを設定することはできません。つまり、internalなクラスを継承して、publicなクラスを定義することはできません。
サブクラスからアクセス可能であれば、スーパークラスのプロパティやメソッドをオーバーライドすることは可能です。</p>

<p>オーバーライドにより、スーパークラスのアクセスレベルより緩いアクセスレベルにすることができます。次の例では、スーバークラスのprivateなメソッドをinternalなアクセスレベルに変更しています。</p>

<pre><code>public class A {
    private func someMethod() {
        :
    }
}

internal class B: A {
    override internal func someMethod() {
        :
    }
}
</code></pre>

<p>また、サブクラスのメソッドのアクセスレベルより厳しいアクセスレベルのメソッドも、ソースからアクセス可能であれば呼び出すことができます。</p>

<pre><code>public class A {
    private func someMethod() {}
}

internal class B: A {
    override internal func someMethod() {
        super.someMethod()
    }
}
</code></pre>

<p>上の場合は、internalなメソッドから、スーパークラスのprivateなメソッドを呼び出していますが、privateなメソッドでも同じソース内であればアクセス可能なので、サブクラスからの呼び出しも可能となります。</p>

<blockquote>
<p>上のクラスAとBがそれぞれ別のソースファイルに記述されている場合は、クラスBからクラスAのprivateなメソッドの呼び出しはできなくなるのでコンパイルエラーになります。</p>
</blockquote>

<p><strong>定数、変数、プロパティ、サブスクリプト</strong></p>

<p>定数、変数、プロパティは、その型のアクセスレベルより緩い設定にすることはできません。例えば、privateな型のpublicなプロパティを宣言することはできません。
また同様に、サブスクリプトのアクセスレベルを、そのインデックスや戻り値の型より緩くすることはできません。
次の様に、privateな型の変数はprivateとして宣言しなくてはなりません。</p>

<pre><code>private var privateInstance = SomePrivateClass()
</code></pre>

<p><strong>ゲッターとセッター</strong></p>

<p>ゲッターとセッターのアクセスレベルは、対象となる定数や変数のアクセスレベルと同じになります。</p>

<p>セッターのアクセスレベルをゲッターより厳しくすることができます。</p>

<p>次の例では、構造体にもプロパティにも明示的にアクセスレベルを指定していないので、アクセスレベルはデフォルトのinternalになりますが、プロパティのセッターにはprivateを設定しています。</p>

<pre><code>/* 値の変更を追跡する文字列 */
struct TrackedString {
    private(set) var numberOfEdits = 0
    var value: String = &quot;&quot; {
        didSet {
            numberOfEdits++
        }
    }
}
</code></pre>

<p>この構造体のnumberOfEditsプロパティは、同じモジュールの別ソースファイルから値を読み取ることはできますが、値の変更は同じソースファイルからしかできないことになります。</p>

<p>この構造体のインスタンスを生成して、valueプロパティの値を変更するたびにnumberOfEditsがインクリメントされます。</p>

<pre><code>var stringToEdit = TrackedString()
stringToEdit.value = &quot;この文字列は追跡されます。&quot;
stringToEdit.value += &quot;値を変更するたびに変更回数が加算されます。&quot;
stringToEdit.value += &quot;さらに変更します。&quot;
println(&quot;変更回数は\(stringToEdit.numberOfEdits)回です。&quot;)

/* 実行結果
変更回数は3回です。
*/
</code></pre>

<p>ゲッターとセッターに明示的にアクセスレベルを設定することもできます。上のTrackedString構造体を別のモジュールからアクセスできるようにするにはpublicを指定します。</p>

<pre><code>public struct TrackedString {
    public private(set) var numberOfEdits = 0
    public var value: String = &quot;&quot; {
        didSet {
            numberOfEdits++
        }
    }
    public init() {}
}
</code></pre>

<p>この場合は、型、プロパティ、イニシャライザ全てにpublicが指定されているので、他のモジュールのソースファイルからもインスタンスを生成し、プロパティにアクセスすることができます。但し、numberOfEditsのセッタにはprivateが指定されているので、同じモジュールのソースファイルも含め他のどのソースファイルからもnumberOfEditsの値を変更することはできません。</p>

<blockquote>
<p>publicな型のプロパティのデフォルトのアクセスレベルはinternalです。他のモジュールのソースファイルからプロパティやメソッドにアクセスできるようにするには、上の例のように明示的にpublicを指定してやる必要があります。</p>
</blockquote>

<p><strong>イニシャライザ</strong></p>

<p>イニシャライザのアクセスレベルはその型のアクセスレベルと同じか、より厳しいアクセスレベルを設定できます。但し、必須イニシャライザ（requiredをつけたイニシャライザ）は、型と同じアクセスレベルにする必要があります。</p>

<p>関数やメソッドの場合と同様、イニシャライザの引数のアクセスレベルをイニシャライザ自体のアクセスレベルより厳しくすることはできません。</p>

<p>Swiftでは、スーパークラスも含めプロパティにデフォルト値が与えられていて且つイニシャライザが明示されていない場合は、引数をとらないイニシャライザ（デフォルトイニシャライザ）が自動的に生成されますが、このデフォルトイニシャライザのアクセスレベルは、その型のアクセスレベルと同じものになります。</p>

<blockquote>
<p>publicな型のデフォルトイニシャライザのアクセスレベルはinternalになります。デフォルトイニシャライザのアクセスレベルをpublicにしたい場合は、引数をとらないイニシャライザをpublicをつけて明示的に記述する必要があります。</p>
</blockquote>

<p>構造体を定義する時に自動的に生成されるメンバワイズイニシャライザは、privateなアクセスレベルをもつプロパティがあればイニシャライザのアクセスレベルもprivateになります。それ以外の場合のアクセスレベルはinternalです。もし、publicなメナバワイズイニシャライザが必要な場合は、上で説明したデフォルトイニシャライザの場合と同様、明示的にメンバワイズイニシャライザを記述する必要があります。</p>

<p><strong>プロトコル</strong></p>

<p>プロトコルにアクセスレベルを設定したい場合は、プロトコルを定義する時に指定します。
プロトコルで定義したメソッドやプロパティのアクセスレベルは、プロトコル自体のアクセスレベルと同じものになります。プロトコルのアクセスレベルと異なるアクセスレベルを指定することはできません。</p>

<blockquote>
<p>publicなプロトコルで宣言されたメソッドやプロパティのアクセスレベルはpublicになります。他のpublicな型のメンバのデフォルトのアクセスレベルはinternalですが、プロトコルの場合は異なっています。</p>
</blockquote>

<p>他のプロトコルを継承したプロトコルを定義する場合、そのプロトコルのアクセスレベルは、継承するプロトコルで許可されたものになります。internalなプロトコルを継承してpublicなプロトコルを定義することはできません。</p>

<p>型をプロトコルへ適合させる場合、そのプロトコルのアクセスレベルより緩いアクセスレベルを指定できますが、その場合はその型へアクセス可能な範囲はプロトコルのアクセスレベルに従うことになります。例えば、internalなプロトコルに適合するpublicな型を定義した場合、その型は同じモジュール内でしか使用できません。
あるプロトコルに適合する型のアクセスレベルは、そのプロトコルとより型の厳しい方のアクセスレベルに従うことになります。</p>

<p>エクステンションにより既存の型をプロトコルへ適合させる場合、その型で実装するプロトコルで定義されたプロパティやメソッドのアクセスレベルが、少なくともプロトコルのアクセスレベルと同じである必要があります。例えば、publicな型をinternalなプロトコルへ適合させる場合は、その型で実装するプロトコルのプロパティやメソッドのアクセスレベルもinternalである必要があります。</p>

<p>プロトコルへの適合はグローバルなものになります。１つのプログラム内で、ある型を同じプロトコルへ重複して適合させることはできません。</p>

<p><strong>エクステンション</strong></p>

<p>エクステンションを使って型を拡張する場合、追加されるメンバは型自体のアクセスレベルに従うことになります。例えばprivateな型に追加したメソッドはprivateに、publicな型に追加したメソッドはinternalになります。</p>

<p>エクステンションを定義する時に型に明示的にアクセスレベルを指定した場合、追加されるメンバのデフォルトのアクセスレベルも変わります。例えば、privateなエンステンションを定義すると追加するメソッドのデフォルトのアクセスレベルはprivateになります。追加するメンバに個々にアクセスレベルを指定してデフォルトのアクセスレベルを上書きすることも可能です。</p>

<p>エクステンションを使って、既存の型をあるプロトコルへ適合させる場合、アクセスレベルはそのプロトコルのアクセスレベルに従うことになるので、明示的にアクセスレベルを指定することはできません。追加するメンバのデフォルトのアクセスレベルもプロトコルのアクセスレベルに従います。</p>

<p><strong>ジェネリクス</strong></p>

<p>ジェネリクス関数やジェネリクス型のアクセスレベルは、その関数や型につけられたアクセスレベルと、パラメータとして使用される型のアクセスレベルの中で最も厳しいアクセスレベルになります。</p>

<p><strong>タイプエイリアス</strong></p>

<p>タイプエイリアスを使って型の別名を定義する場合、その型のアクセスレベルは、元の型のアクセスレベルと同じか、より厳しいアクセスレベルを指定することができます。例えば、internalな型の別名としてprivateな型を定義することはできますが、internalな型の別名としてpublicな型を定義することはできません。このルールはタイプエイリアスを使って、プロトコルの中で関連型（Associated Types）を定義する場合も同様です。</p>

<h2 id="演算子のオーバーロード">演算子のオーバーロード</h2>

<p>クラスや構造体に既存の演算子について独自の振る舞いを与えることができます。これを演算子のオーバーロードと呼びます。</p>

<p>ここでは、分数を表す次のような構造体に演算子を実装することを考えてみます。</p>

<pre><code>/* 分数 */
struct Fraction {
    var numerator: Int      // 分子
    var denominator: Int    // 分母
    // 分数形式の文字列で返す
    var asString: String {
        let hcf = findHCF()
        let str = &quot;\(abs(numerator) / hcf) / \(abs(denominator) / hcf)&quot;
        return numerator * denominator &lt; 0 ? &quot;- &quot; + str : str
    }
    // 最大公約数を求める
    func findHCF() -&gt; Int {
        for var i=max(numerator, denominator); i&gt;=1; i-- {
            if numerator % i == 0 &amp;&amp; denominator % i == 0 {
                return i
            }
        }
        return 1
    }
}

let f = Fraction(numerator: 6, denominator: 15)
print(f.asString)     // -&gt; 2 / 5
</code></pre>

<p><strong>2項演算子</strong></p>

<p>上の構造体に対して、+演算子をオーバーロードしてみます。次の様になります。</p>

<pre><code>/* 分数の足し算　*/
func + (left: Fraction, right: Fraction) -&gt; Fraction {
    let numerator = left.numerator * right.denominator + right.numerator * left.denominator
    let denomitor = left.denominator * right.denominator
    return Fraction(numerator: numerator, denominator: denomitor)
}

let f1 = Fraction(numerator: 2, denominator: 3)
let f2 = Fraction(numerator: 4, denominator: 5)
let f3 = f1 + f2
print(f3.asString)    // -&gt; 22 / 15
</code></pre>

<p>+演算子は、オペランド（演算対象）を2つ持つ2項演算子です。これをSwiftではinfix（間に置くという意味）と表現します。上の例では演算対象として、演算子の左側をleft、右側をrightというFraction型の引数で受け取り、結果もFraction型で返しています。</p>

<p>演算子はこのように、型のメソッドとしてではなく、グローバル関数として定義します。</p>

<p><strong>単項演算子</strong></p>

<p>次は分数の符号を反転させる-演算子を定義します。これは単項演算子になりますが、オペランドの前に演算子がつくのでprefix（前に置くという意味）という修飾子が必要になります。</p>

<pre><code>/* 符号の反転 */
prefix func - (fraction: Fraction) -&gt; Fraction {
    return Fraction(numerator: -fraction.numerator, denominator: fraction.denominator)
}

let f1 = Fraction(numerator: 4, denominator: 10)
print(f1.asString)    // -&gt; 2 / 5
let f2 = -f1
print(f2.asString)    // -&gt; - 2 / 5
let f3 = -f2
print(f3.asString)    // -&gt; 2 / 5
</code></pre>

<p><strong>複合代入演算子</strong></p>

<p>次は、代入演算に別の演算を組み合わせた複合代入演算です。+=演算子を使って他の値を加算できるようにします。</p>

<pre><code>/* 分数の加算　*/
func += (inout left: Fraction, right: Fraction) {
    left = left + right
}

var f1 = Fraction(numerator: 2, denominator: 5)
let f2 = Fraction(numerator: 3, denominator: 4)
f1 += f2
println(f1.asString)    // -&gt; 23 / 20
</code></pre>

<p>左辺のオペランドの値は変更されるので、引数にinoutの指定が必要になります。+演算子は既に実装済みなので、+=演算子の実装の中で使用することができます。</p>

<p>この演算子を実際に使用する時には、非演算対象は値が変更されるので、定数ではなく、変数として宣言する必要があります。</p>

<p>ここで実装した++演算子を使ってさらに、値を1加算する++演算子を次のよにう実装できます。</p>

<pre><code>prefix func ++ (inout fraction: Fraction) -&gt; Fraction {
    fraction += Fraction(numerator: 1, denominator: 1)
    return fraction
}

var f = Fraction(numerator: 2, denominator: 3)
++f
println(f.asString)     // -&gt; 5 / 3
</code></pre>

<blockquote>
<p>このように独自に定義した型に対して様々な演算子をオーバーロードできますが、代入演算子（=）と3項演算子（a ? b : c）のオーバーロードはできません。</p>
</blockquote>

<p><strong>等価演算子</strong></p>

<p>次は、値が等しいかどうかを判定する==演算子と!=演算子です。独自の型に対してこれらの演算子をSwiftが自動的に生成してくれることはありません。様々な意味を持つ型に対してそれらが等しい、或いは等しくないことを類推することができないためです。</p>

<pre><code>/* 等価判定 */
func == (left: Fraction, right: Fraction) -&gt; Bool {
    return left.asString == right.asString
}
func != (left: Fraction, right: Fraction) -&gt; Bool {
    return !(left == right)
}

let f1 = Fraction(numerator: 2, denominator: 3)
let f2 = Fraction(numerator: 3, denominator: 5)
let f3 = Fraction(numerator: 4, denominator: 6)

println(f1 == f2)   // false
println(f1 == f3)   // true
println(f1 != f2)   // true
</code></pre>

<p>ここでは単純に、分数の文字列表現が等しいかどうかで判定しています。また、!=演算子は、==演算の結果を反転させています。</p>

<p><strong>独自の演算子</strong></p>

<p>Swiftでは既存の演算子だけでなく新たな演算子を定義することもできます。
ここでは分数の逆数を返す、~~演算子を定義してみます。~~は既存の演算子ではないので、グローバルに使用できるよう に、operatorキーワードを使って 宣言する必要があります。</p>

<pre><code>prefix operator ~~ {}
</code></pre>

<p>演算子の種類に応じて、operator の前に、prefix（前に置く）, infix（間に置く）, postfix（後に置く）の何れかを指定します。ここでは、prefixを指定しています。</p>

<p>実装は次の様になります。</p>

<pre><code>prefix func ~~ (inout fraction: Fraction) -&gt; Fraction {
    fraction = Fraction(numerator: fraction.denominator, denominator: fraction.numerator)
    return fraction
}

var f = Fraction(numerator: 3, denominator: 5)
~~f
println(f.asString)     // -&gt; 5 / 3
</code></pre>

<p><strong>優先度と結合性</strong></p>

<p>独自のinfix演算子を定義する場合は、その優先度と結合性を指定することができます。</p>

<p>優先度は、オベランドの両側に演算子がある場合に、どちらの演算子の演算を優先するかという指定です。また、結合性はオペランドの両側に優先度が同じ演算子がある場合にどちらを優先するかという指定です。</p>

<pre><code>5 + 2 * 6 / 3
</code></pre>

<p>という計算式の場合、2の両側にある「+」と「*」では「*」の方が優先度が高いので、右側の演算が先に行われます。次に6の両側にある「*」と「/」の優先度は同じですが、結合性はどちらも左側への結合になっているので、「2 * 6」が先に計算されます。ここまでで次のようになります。</p>

<pre><code>5 + 12 / 3
</code></pre>

<p>「+」と「/」では「/」の方が優先度が高いので、「12 / 3」が先に計算されて、次の様になります。</p>

<pre><code>5 + 4
</code></pre>

<p>最後に「5 + 4」が計算され、結果は9になります。</p>

<p>別の例を見てみます</p>

<pre><code>let a = 1000 / 20 / 5
</code></pre>

<p>「/」は左側への結合性を持つ演算子です。上の式は以下と同じです。</p>

<pre><code>let a = ((1000 / 20) / 5)
</code></pre>

<p>もし「/」が右側への結合性を持っていたとすると次のような演算の順序になり結果が異なることになります。</p>

<pre><code>let a = (1000 / (20 / 5))
</code></pre>

<p>Swiftで予め定義されている演算子で右側への結合性をもつ演算子は、代入系の演算子の他は「??」と3項演算子の「? :」だけです。それ以外は左側への結合性か、結合性の無い演算子になります。</p>

<pre><code>var a: Int?
var b: Int?

let c = a ?? b ?? 10    // 10
</code></pre>

<p>独自の演算子に対して結合性が指定されない場合、デフォルト値の「無し」が設定されます。また、優先度が指定されない場合、デフォルト値は100です。</p>

<p>次に明示的に結合性と優先度を指定する例を示します。</p>

<pre><code>/* 絶対値を返す演算子　*/
infix operator |-| { associativity left precedence 140 }

/* 2つの分数の絶対値を返す */
func |-| (left: Fraction, right: Fraction) -&gt; Fraction {
    let f = left + (-right)
    return Fraction(numerator: abs(f.numerator), denominator: abs(f.denominator))
}

let f1 = Fraction(numerator: -3 , denominator: 4)
let f2 = Fraction(numerator: 2, denominator: 5)
let f3 = f1 |-| f2
println(f3.asString)    // -&gt; 23 / 20
</code></pre>

<p>ここで指定している、左側への結合と140という優先度は、加算（+）や減算（-）と同じ設定です。</p>
</div>

  <footer class="article-footer">

    <aside class="share">
  <a href="http://b.hatena.ne.jp/add?mode=confirm&url=https%3a%2f%2ffumimi.github.io%2fmy-blog-space%2fposts%2fswift-basic%2f&title=Swift%e3%82%92%e5%ad%a6%e3%81%b6" title="はてなブックマーク" class="ht" target="_blank" rel="nofollow">B!</a>
  <a href="http://twitter.com/intent/tweet?url=https%3a%2f%2ffumimi.github.io%2fmy-blog-space%2fposts%2fswift-basic%2f&text=Swift%e3%82%92%e5%ad%a6%e3%81%b6&tw_p=tweetbutton" title="Twitterでシェア" class="tw" target="_blank" rel="nofollow"><i class="fa fa-twitter" aria-hidden="true"></i></a>
  <a href="http://www.facebook.com/sharer.php?u=https%3a%2f%2ffumimi.github.io%2fmy-blog-space%2fposts%2fswift-basic%2f&t=Swift%e3%82%92%e5%ad%a6%e3%81%b6" title="Facebookでシェア" class="fb" target="_blank" rel="nofollow"><i class="fa fa-facebook" aria-hidden="true"></i></a>
  <a href="https://plus.google.com/share?url=https%3a%2f%2ffumimi.github.io%2fmy-blog-space%2fposts%2fswift-basic%2f" title="Google Plusでシェア" class="gp" target="_blank" rel="nofollow"><i class="fa fa-google-plus" aria-hidden="true"></i></a>
  <a href="http://getpocket.com/edit?url=https%3a%2f%2ffumimi.github.io%2fmy-blog-space%2fposts%2fswift-basic%2f&title=Swift%e3%82%92%e5%ad%a6%e3%81%b6" title="Pocketに保存" class="pk" target="_blank" rel="nofollow"><i class="fa fa-get-pocket" aria-hidden="true"></i></a>
  <a href="http://line.me/R/msg/text/?Swift%e3%82%92%e5%ad%a6%e3%81%b6 https%3a%2f%2ffumimi.github.io%2fmy-blog-space%2fposts%2fswift-basic%2f" title="LINEでシェア" class="ln" target="_blank" rel="nofollow">LINE</a>
</aside>


    <section class="footer">
      <div>
        <nav class="crumb">
          <ol>
            <li><a href="https://fumimi.github.io/my-blog-space/"><i class="fa fa-home" aria-hidden="true"></i>TOP</a></li>
            
            <li itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb"><a href="https://fumimi.github.io/my-blog-space/posts/" itemprop="url"><span itemprop="title">POSTS</span></a></li>
            
            <li class="active">Swiftを学ぶ</li>
          </ol>
        </nav>
      </div>
    </section>

    
    
    
    <section class="footer">
      <header>
        <a href="https://fumimi.github.io/my-blog-space/categories/">CATEGORIES</a>
      </header>
      <div>
        <ul class="terms">
          
          <li><a href="https://fumimi.github.io/my-blog-space/categories/swift/">swift</a></li>
          
        </ul>
      </div>
    </section>
    
    
    
    <section class="footer">
      <header>
        <a href="https://fumimi.github.io/my-blog-space/tags/">TAGS</a>
      </header>
      <div>
        <ul class="terms">
          
          <li><a href="https://fumimi.github.io/my-blog-space/tags/swift/">swift</a></li>
          
          <li><a href="https://fumimi.github.io/my-blog-space/tags/ios/">iOS</a></li>
          
        </ul>
      </div>
    </section>
    
    
  </footer>

</article>


    <div class="adj">
      <div class="mrow">
        
        <div class="mcol c6">
          <header>Previous Article</header>
          <article class="lism">
  <a href="https://fumimi.github.io/my-blog-space/posts/object-array/">
    <div class="thumb thumb-73fc7deb3f652a22833fb3f4da0ed2eb"></div>

    <div class="inner">
      <div class="title">Arrayオブジェクト（配列を操作する）</div>

      <ul class="facts sm">
        <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2017-10-15T17:34:13JST">Oct 15, 2017</time></li>
        <li><i class="fa fa-bookmark" aria-hidden="true"></i>POSTS</li>
        
      </ul>

    </div>
  </a>
</article>

        </div>
        
        
      </div>
    </div>

    
  </div>
  <div class="mcol c4">
    <aside class="l-sidebar">

  <div class="sections sidebar">
    

    <section class="sidebar">
  <header>LATESTS</header>
  <div>
    <div class="articles sm">
      
      <article class="lism">
  <a href="https://fumimi.github.io/my-blog-space/posts/swift-basic/">
    <div class="thumb thumb-dbde06035db760652386e5fc4994ce99"></div>

    <div class="inner">
      <div class="title">Swiftを学ぶ</div>

      <ul class="facts sm">
        <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2017-10-22T08:30:59JST">Oct 22, 2017</time></li>
        <li><i class="fa fa-bookmark" aria-hidden="true"></i>POSTS</li>
        
      </ul>

    </div>
  </a>
</article>

      
      <article class="lism">
  <a href="https://fumimi.github.io/my-blog-space/posts/object-array/">
    <div class="thumb thumb-73fc7deb3f652a22833fb3f4da0ed2eb"></div>

    <div class="inner">
      <div class="title">Arrayオブジェクト（配列を操作する）</div>

      <ul class="facts sm">
        <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2017-10-15T17:34:13JST">Oct 15, 2017</time></li>
        <li><i class="fa fa-bookmark" aria-hidden="true"></i>POSTS</li>
        
      </ul>

    </div>
  </a>
</article>

      
      <article class="lism">
  <a href="https://fumimi.github.io/my-blog-space/posts/npm/">
    <div class="thumb thumb-921cf0cef52072d2b24f8c6cd92bf8b8"></div>

    <div class="inner">
      <div class="title">npmの使い方について</div>

      <ul class="facts sm">
        <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2017-10-15T16:23:11JST">Oct 15, 2017</time></li>
        <li><i class="fa fa-bookmark" aria-hidden="true"></i>POSTS</li>
        
      </ul>

    </div>
  </a>
</article>

      
      <article class="lism">
  <a href="https://fumimi.github.io/my-blog-space/posts/my-first-post/">
    <div class="thumb thumb-583bc6c089052d23ac6c3a855c17f6df"></div>

    <div class="inner">
      <div class="title">hugo（Markdown記法のチートシート）</div>

      <ul class="facts sm">
        <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2017-10-15T15:44:10JST">Oct 15, 2017</time></li>
        <li><i class="fa fa-bookmark" aria-hidden="true"></i>POSTS</li>
        
      </ul>

    </div>
  </a>
</article>

      
      
      
      
      
      
      
      
      
      
      
      
      
    </div>
  </div>
</section>

    
<section class="sidebar">
  <header>CATEGORIES</header>
  <div>
    <ul class="terms">
      <li><a href="https://fumimi.github.io/my-blog-space/categories/hugo">hugo</a></li><li><a href="https://fumimi.github.io/my-blog-space/categories/javascript">javascript</a></li><li><a href="https://fumimi.github.io/my-blog-space/categories/swift">swift</a></li>
    </ul>
  </div>
</section>



    
<section class="sidebar">
  <header>TAGS</header>
  <div>
    <ul class="terms">
      <li><a href="https://fumimi.github.io/my-blog-space/tags/hugo">hugo</a></li><li><a href="https://fumimi.github.io/my-blog-space/tags/markdown">markdown</a></li><li><a href="https://fumimi.github.io/my-blog-space/tags/ios">ios</a></li><li><a href="https://fumimi.github.io/my-blog-space/tags/javascript">javascript</a></li><li><a href="https://fumimi.github.io/my-blog-space/tags/swift">swift</a></li>
    </ul>
  </div>
</section>



  </div>

</aside>

  </div>
</div>

      </div>
    </main>

    <footer class="l-footer">
      <div class="l-container">
        <p><span class="h-logo">&copy; My Blog Space.</span></p>
        <aside>
          <p>Powered by <a href="https://gohugo.io/">Hugo</a>.</p>
          <p><a href="https://github.com/dim0627/hugo_theme_robust">Robust</a> designed by <a href="http://yet.unresolved.xyz/">Daisuke Tsuji</a>.</p>
        </aside>
      </div>
    </footer>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>

